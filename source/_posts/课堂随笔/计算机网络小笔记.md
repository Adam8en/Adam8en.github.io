---
title: 计算机网络小笔记
date: 2023-09-15 12:06:59
tags: 计算机网络
categories: 课堂随笔
cover: https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/301790.jpg
description: 主要是个人关于计算机网络的一些课堂随笔
updated: 2023-12-08 12:51:46
---

这里是关于计算机网络的一些知识点笔记，综合学校的PPT和个人的一些理解记录，适合初步学习以及考前复习ლ(°◕‵ƹ′◕ლ)。

另外此篇文章会长期更新！

----

# 计算机网络

## 分层模型

- 优点：各层独立，灵活性好
- 缺点：降低了效率，产生额外开销

## 互联网分层模型

### TCP/IP

- 应用层/application layer：支持网络应用；HTTP，SMTP，WWW
- 运输层/transport layer：进程间数据传输：TCP，UDP
- 网络层/network layer：从起点到终点的数据报文路由；IP，各类路由协议
- 链路层/data link layer：相邻网络元素的数据传输；WiFi
- 物理层/physical layer：传输比特

### OSI

在TCP/IP的应用层和运输层间增加了表示层和会话层，一共七层协议。

两个AP的信息传输流程，依次从AP1的第五层下降到第一层，每一层都对原来的数据加上新的数据头，然后再从第一层物理层传输比特到另一个AP的物理层，最后依次上升并剥离添加的数据头，把数据交给AP2。

### 协议

假设两个同样的层次把数据通过水平虚线直接传递给对方，这就是所谓的“对等层”之间的通信。

各个对等层之间传输数据的各项规定统称为协议。

在计算机网络中，我们只关注对等层的通信细节。

- **实体**表示任何可发送或接收信息的硬件或软件进程
- **协议**是控制两个对等实体进行通信的规则的集合
- 在协议的控制下，两个对等实体的通信使得本层可以**向上一层提供服务**（因为剥离了对等层添加的数据头）
- 要实现本层新协议，还需要**使用下层提供的服务**（需要下层剥离他们的数据头才可以识别数据剥离本层数据头）

## 链路层和局域网

### 链路层概述

- 节点（node）：主机、路由器等
- 链路（links）：通信链路
  - 有线
  - 无线
  - 局域网
- 帧（frame）：数据包
- 链路层负责将一个节点，通过一条链路，将数据传递到**物理相邻**的另一个节点

### 链路层的实现

在主机和路由器之间传递信息时，主机需要实现全五层，而路由器则需要实现包括网络层的下三层。在主机和交换机之间传递信息时，主机仍需实现五层，而交换机则只需要实现包括链路层的下两层。由此易知，数据传输中任何设备都需要经过数据链路层。

- 链路层在每一个主机/交换机上都必须实现
- 链路层的具体实现体现在主机的网卡、适配器、芯片上

### 差错检测

- 在信号传输中，因为信号放大，噪声等问题，导致比特差错
  - 欲发送0，却发送1；反之亦然
  - 可能是1位出错，也可能是多比特出错

- 在实际传输中，错误比特数所占传输的总比特数的比率称为**误码率BER（Bit Error Rate）**

- 误码率和信噪比有很大关系
- 为了保证数据传输的可靠性，在传输数据时必须进行差错检测，广泛使用的方法是**循环冗余检验CRC**技术，由接受者更正比特差错，而不需要重传。

#### 奇偶校验

奇偶校验时一个简单的例子。

若数据中有奇数个1，则奇数校验位为1，反之为0。

当采用二维奇偶校验时，可以检测并更正单个的错误。（类似于九宫格？）

#### 循环冗余检验-CRC(Cyclic Redundancy Check)

CRC是比奇偶检验更复杂更强大的一种方法。

- 在发送端，先把数据划分为组，假定每组为k比特。
- 在每组M后面再添加n位的冗余码，再发送出去

##### 如何计算冗余码

- 先在k位数据后添加n位0作为冗余码，n由后续给定的除数确定
- 再将k+n位数据去除以一个长度为n+1位的除数p，得到一个长度为n的**余数**，这个余数就是冗余码FCS
- 传输完成后再用传输后的数据除以除数p，得到余数R。
- 检验R，若R的某位不为0，则该位数据为假；若为0，则数据为真。

注意事项

- 选择除数，可以随机选择，也可以按照既定标准。除数往往也用多项式表示，所以CRC又称多项式编码方法，这个多项式也称为生成多项式。

  - 例如：生成多项式G(x)=x^4^+x^3^+1对应的生成除数为11001

  - 按照国际通行标准，除数的最高和最低位必须为1

- CRC可以做到“无差错接受”（凡是接受的帧，我们就有极高的概率认定它在传输的过程中没有差错）
- 但是我们并不能做到可靠传输（发送什么就收到什么）
  - 顺序可能被打乱，因此我们必须加上确认和重传机制（由其他协议负责）

### 广播信道

链路层有两种不同的链路形式

- 点对点形式（point to point）形式；采取PPP协议进行通信，专享信道，现在用的不多。
- 广播形式；如局域网，无线局域网等

#### 多接入协议

在广播信道中，往往只有一条共享的广播信道，但是却拥有两个或多个节点，可能会同时发生数据传输，这会导致干涉发生（碰撞）

所以我们需要引入多接入协议，采取分布式算法。

一共有三类典型的多接入协议

- 信道划分
  - 把信道划分为小块
  - 每一个小块被一个节点独享
- 随机接入
  - 不划分信道，允许碰撞
  - 尝试从碰撞中恢复
- 受控接入
  - 节点流式发送
  - 不划分信道，也不允许碰撞

##### 信道划分-TDMA

TDMA: time division multiple access 时分复用

节点分轮使用信道，每个节点在每一轮都会获得定长的slot，分配但未用的节点保持闲置

##### 信道划分-FDMA

信道的频谱划分为不同的频段

每个节点使用固定的频段发送数据

未发送的节点保持闲置

##### 随机接入

- “随机”：有一个节点需要发送数据时就占满带宽全速发送，不需要经过节点之间的协调。
- “碰撞”：当多个节点发送数据，则会导致碰撞。
- 协议：主要用来侦测是否发生碰撞以及如何从碰撞中恢复。

###### Slotted ALOHA

是一个七十年代提出的早期协议，十分简单

基本假设：

- 所有帧大小一致
- 时间轴被划分为等长的时隙（slots），每个时隙的长度通常是传递一帧的时间
- 节点均只在时隙开始时进行传输
- 若超过两个节点在同一时隙传输数据，则所有节点均能检测到碰撞

操作：

- 当一个节点获得一个新的帧时，在下一个时隙开始传输：
  - 若没有碰撞，则数据传输成功
  - 若发生碰撞，则传输失败，该节点在之后的每一个时隙以概率p进行重传，直至传输成功。

优点：

- 每个时隙中，都有一个节点可以一直进行全速传输
- 高度分布式算法：只需要把多有节点的时隙进行同步，其余工作都由节点自行探测解决
- 算法十分简单

缺点：

- 碰撞会浪费很多时隙，也有很多时隙是闲置的
- 需要一个时隙去检测是否发生碰撞，然而节点检测碰撞只需要更少的时间
- 需要时钟同步

###### CSMA协议家族

- CSMA: Carrier Sense Multiple Access 载波监听多点接入
- 发送数据前先监听广播信道，如果信道空闲则发送整个帧；如果正忙，则延迟发送
- 类比“不打扰他人说话”

此处主要讲述CSMA/CD（Collision Detection 碰撞检测）

- 短时间内侦测是否发生碰撞，如碰撞发生则停止传输
- 只能在IEEE 802.3 有线局域网使用
- 无线局域网不适用，在无线网中很难通过信号强度判定碰撞是否发生

碰撞检测就是计算机边发送数据边监测信道上的信号电压大小，当几个节点同时传输数据时，信号电压摆动会增大（互相叠加），当一个站检测到信号电压摆动值超过一定的门槛后，就认为发送了碰撞，然后就会暂停发送数据，等待一段随机的时间后再进行发送。

最先发送数据的站，在经过2τ的争用期内才能检测到碰撞。现在一般把争用期设定为51.2us，对应传输的数据长度为64byte。

也就是说，只要前64byte没有发生碰撞，该帧后续的传输也不会发生碰撞。

终止发送后，网卡NIC进入**二进制指数退避**（binary exponential backoff）

- 基本退避时间为2τ
- 若已经经过m次重传，则随即从整数集合{0,1,...,2^m^-1}中随机选择一个数，定为k。重传所需时延即为k倍的试用期。
- 重传16次仍然不能成功，则丢弃该帧，并向更高层协议报告。

CSMA/CD效率比Slotted ALOHA更高，简单，便宜，完全去中心化。

##### 受控接入

###### Taking turns 轮流接入

轮询 polling：

- 主节点master邀请次节点slave node轮流发送数据
- 典型场景：次节点不具备智能，是dumb service
- 存在的问题：
  - 轮询开销
  - 延迟
  - 单点故障（即master节点一故障，所有系统都瘫痪）
  - 存在政治正确问题

令牌传递 token passing：

- 受控的令牌从一个节点依次传递到下一个节点
- 有令牌的节点可以发送帧
- 存在的问题：
  - 开销
  - 延迟
  - 单点故障（令牌本身被黑客替换，所有系统瘫痪）

### 链路层的寻址

#### MAC地址

即Media Access Control，也称为局域网地址、硬件地址、物理地址、以太网地址

一共48位（6字节），通常烧录进NIC的ROM中，有时候也可以通过软件设定

注意：并不是一台电脑或者一台路由器/交换机只有一个Mac地址，Mac地址是端口绑定的

前3字节用于组织唯一标识符，后3字节用于拓展唯一标识符，由厂家指派，必须保证生产出的适配器没有重复地址。

#### NIC检查Mac地址

适配器从网络上收到每一个Mac帧就首先会用硬件检查Mac帧中的Mac地址。如果是发往本站的帧，就收下，反之就将此帧丢弃。

发往本站的帧有以下三种：

- 单播帧（一对一）
- 广播（一对全体）
- 多播（一对多）

## 以太网（Ethernet）

以太网是现在事实上的主流有线局域网技术

- 单一芯片，可以实现多种带宽
- 第一个广泛采用的局域网技术
- 简单便宜速度快

以太网过去采用**总线拓扑**，所有节点处于同一碰撞域。现在使用星型拓扑，采用交换机。

### 以太网的帧结构

![img](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/20230915103251.png?x-oss-process=style/blog)

**preamble：**

一共八个字节，用于实现Mac帧的比特同步，以及界定Mac帧的开始。

**dest address/source address**：

各自6字节的Mac地址。如果NIC收到的帧目的地址匹配自己的Mac地址，或者收到广播地址，就把帧传输至上一层网络层协议。

**type：**

表示“上一层协议”，即收到帧后应该传给网络层的哪一种协议。多数情况下是IP协议，也有可能有其他的IP层协议。

**CRC：**

4字节的CRC校验码。若检查出错误，直接丢弃该帧，不进行重传。

传输时可能会遇到无效的帧，有以下几种情况：

- 帧的长度不是整数字节
- CRC校验失败
- 数据字段长度不在46~1500字节之间
- MAC帧长度不在64~1518字节之间

检查出无效的Mac帧就直接丢弃，以太网不负责重传丢弃的帧。

### 不可靠、无连接的以太网

- 无连接：发送和接收的NIC不需要握手进行连接

- 不可靠：接受的NIC不需要想发送的NIC表达是否接收到帧。

  若帧被丢弃，则只能通过上层协议恢复，否则直接丢弃，数据丢失。

  Ethernet用到的信道复用协议是unslotted CSMA/CD with binary backoff

## 交换机

### 为什么使用交换机

主要用于拓展以太网，将不同的网络连接在一起。

交换机是链路层设备，它储存并转发以太网帧，并且检查收到帧的Mac地址，选择性地将它转发到多个链路。

交换机是透明的，主机不知道交换机存在。

交换机即插即用，自学习，不需要进行手动配置，它将自动学习网络拓扑。

交换机可以实现无碰撞的传输数据，碰撞区域被局限在交换机的每一个借口。

### 交换机的特点

- 交换机有十几个或者更多的接口
- 交换机有并行性，能同时对接多接口，使多对主机同时通信
- 交换机接口有储存器，能在输出繁忙时将到来的帧进行缓存
- 交换机使用专用的交换结构芯片，使用硬件转发，转发速率非常的高
- 交换机的性能远远超过普通的集线器，而且价格不贵

### 交换表/转发表 forwarding table

每一个交换机有一个交换表，交换表上有：主机的Mac地址，通过哪个接口访问，有效时间。表的内容创立于维护通过交换机的自学习功能进行。

当交换机收到帧时，交换机会记录帧的来源Mac地址和目的地Mac地址，之后在交换表中查找。

若交换表中有对应的地址，则继续进行判断：

- 若目的地和帧的来源一样，则丢弃该帧
- 若不一样，则发送数据

若没有找到对应的条目，则进行**泛洪**。即将数据从除了进来的接口外的所有接口转发该帧。

### 以太网交换机的自学习功能

开始时，表中的内容是空的。

首先A使用接口1向B发送一帧，那么交换机首先会把接口1和帧的原地址A记录在表中。随后查找交换表，查找不到应该从哪个接口转发数据给B，接着进行泛洪，向除了接口1外的所有接口广播该帧。

由于该帧与目的地不同，C和D将丢弃该帧，而B收到信息。

若B向A发送一帧，交换机先重复和A一样的工作记录B使用的接口和地址，随后查找交换表。这一次查找到了A的接口和Mac地址，所以直接发送数据而无须进行泛洪。

考虑到交换机的接口可能会更换主机或者网络适配器，所有每一个交换机项目都有一定的有效时间。国旗的项目会被自动删除。

这种自学习的方法使得交换机能够即插即用，不用进行人工配置，所以十分方便。

## 虚拟局域网

### VLAN的定义

假如CS用户把办公室移到了EE系的楼，但是仍然希望连接CS系的局域网。如果只采用一个广播域，那么所有的链路层流量都需要经过整个局域网，带来了安全、隐私和效率问题。

虚拟局域网 VLAN 是由一些局域网网段构成的与物理位置无关的逻辑组，而这些网段具有某些共同的需求。每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的计算机是属于哪一个 VLAN。

![img](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/20230922085116.png?x-oss-process=style/blog)

由上图所示，在没有VLAN时，只有每一层的主机能构成局域网，如果想要通过主机向其他局域网发送消息，那么第一次发送肯定要经过泛洪发送给其他无关成员。但如果使用了VLAN，使得发送的帧带上了特定标识符，让数据直接到达目标主机。

特定的标志符将以4字节的形式插入以太网的帧结构中，即802.1Q帧。

## 网络层/数据平面和控制平面

网络层的作用是从发送端到接收端传递数据段。在发送端将数据包装成数据报，在接收端将数据报解包然后传送到传输层。每个主机/端/路由都需要部署网络层（交换机排除在外，属于链路层）。在传输数据报时，由路由器检查数据报的首部，并决定使用什么路径发送IP数据报。

现在的互联网是“无连接”，“尽最大努力的”。即网络层向上只提供简单的、无连接的、尽最大努力交付的数据报服务。发送分组时不需要先建立连接，不提供服务质量的承诺。

如果主机中的进程之间的通信需要可靠，那么就由主机中的运输层负责可靠交付（差错处理，流量控制）。这样使得网络的造价大大降低。

一般来说，我们把基于单个本地路由器，只负责转发的平面称为数据平面；而作用于整个网络连接，负责路由的平面称为控制平面。

## 路由器基础

这一节太抽象了（很多图且全英），建议直接去看PPT。

## IP协议

网际协议IP是TCP/IP协议中最主要的两个协议之一。

如果我们只从网络层考虑问题，那么我们就可以把IP数据报看成只在网络层传输。

我们把互联网看成一个单一的、抽象的网络。IP地址就是给每个连接在互联网上的主机（或者路由器）分配一个在全世界范围内是唯一的32位标识符。一般用形如X.X.X.X的方式表示，每个X对应8位的二进制数。

### IP地址的分类

我们将每一个IP地址划分为固定的类，每一类地址都由两个固定长度的字段组成，其中一个字段是网络号net-id，它标志主机（或路由器）所连接到的网络，而另一个字段则是主机号host-id，它标志该主机（或路由器）。主机号在它前面的网络号所指明的网络范围内必须是唯一的。

由此可见，一个IP地址在整个互联网范围内唯一。

IP地址指向的是一个网络范围，也就是说它会随着主机的位置改变而发生改变，而MAC地址则是唯一的，指向一台具体的设备，不随位置的改变而改变。

每个IP地址的分类网络号和主机号占的位数可能不一样，但是总的一定是32位。

一般来说有以下几种分类：

![img](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/20230922104215.png?x-oss-process=style/blog)

我们对于IP地址的书写采用点分十进制，实际上就是将机器中存放的32位二进制IP地址代码每8位位一组取出，然后将其转换为十进制数，再加上点。

如：10000000 00001011 00000011 00011111

转化为128.11.3.31

知道这些后，我们就可以算出上图中ABC三种IP地址的指派范围。

| 网络类别 | 最大可指派网络数   | 第一个可指派的网络号 | 最后一个可指派的网络号 | 每个网络中最大主机数 |
| -------- | ------------------ | -------------------- | ---------------------- | -------------------- |
| A        | 126（2^7^-2）      | 1                    | 126                    | 16777214             |
| B        | 16383（2^14^-1）   | 128.1                | 191.255                | 65534                |
| C        | 2097151（2^21^-1） | 192.0.1              | 223.255.255            | 254                  |

这里还有一些一般不使用的特殊IP地址

| 网络号 | 主机号             | 源地址使用 | 目的地址使用 | 代表的意思                                 |
| ------ | ------------------ | ---------- | ------------ | ------------------------------------------ |
| 0      | 0                  | 可以       | 不可         | 在本网络上的本主机                         |
| 0      | host-id            | 可以       | 不可         | 在本网络上的某台主机                       |
| 全1    | 全1                | 不可       | 可以         | 只在本网络上进行广播（各路由器不进行转发） |
| net-id | 全1                | 不可       | 可以         | 对net-id上的所有主机进行广播               |
| 127    | 非全0或全1的任何数 | 可以       | 可以         | 用与本地软件环回测试                       |

### IP地址的一些重要特点

- IP地址是一种分等级的地址结构。IP地址管理机构只分配网络号，主机号则由网络号单位自行分配，方便了IP地址的管理。路由器仅由目的主机所连接的网络号来转发分组，这样就使得路由表中的项目书大为减少，减少了路由表的储存空间
- 实际上IP地址是标志一个主机（或者路由器）和一条链路的接口。一个主机同时连接到两个网络时，就具有两个IP地址，网络号id-net必定不同。这种主机称为多归属主机而路由器则必须至少连接两个网络，才能将IP数据报从一个网络转发至另一个网络，故路由器至少有两个IP地址
- 用交换机连接起来的局域网仍为一个网络，局域网具有相同的网络号net-id

切记IP地址与硬件地址是不同的。

IP地址最大的作用在于：IP层抽象的互联网隐藏了下层很复杂的细节（如MAC地址的流动）。在抽象的网络层上讨论问题，就能够使用统一的、抽象的IP地址，研究主机和主机或者主机和路由器之间的通信。

### 为什么不直接使用硬件地址进行通信？

- 世界的各个设备硬件地址存在着很多差异，使用硬件地址并将他们转换为统一的格式几乎不可能做到
- 连接互联网的主机要求其拥有一个唯一的地址，要确保硬件地址唯一极其困难，而使用由软件生成的虚拟IP地址则方便许多

### ARP协议

我们知道一台主机的IP地址，但我们要如何获取它的MAC地址呢？所以我们需要ARP协议。它主要包括以下内容：

- 网络层每一个节点（主机、路由、交换机……）中都储存着一张ARP表，里面有着IP地址和MAC地址的映射。
- 经过每一轮TTL（类似于DDL，一般20分钟左右）后，表中的内容会被遗忘

一般来说，在同一局域网内，ARP协议是这么运作的：

- A发送数据报给B，假设A的ARP表中没有B的MAC地址。即A在网络层知道B的位置，但是链路层不知道
- A发送广播ARP查询**packet**，包含B的IP地址
  - 该packet的目的MAC地址是FF-FF-FF-FF-FF-FF（广播）
  - 局域网中所有节点都收到该查询
- B收到了该查询，并发送自身的MAC地址给A，此时是**单播**，即直接发送给A的MAC地址
- A更新ARP表，直到信息过时
- ARP协议是即插即用的，类似于交换机的过程

## 子网划分

### 为什么要划分子网？

在ARPANET早期，IP地址划分不够合理。

- IP地址利用率低
- 给每一个物理网络分配一个网络号会使得路由表太大而网络性能变坏
- 两级的IP地址不够灵活<网络号、主机号>

于是我们引入了子网，即三级的IP地址<网络号，子网号，主机号>

### 划分子网的思路

划分子网纯属一个单位内部的事情，对外IP地址仍然表示为普通的二级IP地址

主要方法就是从原先的主机号中借用若干个位作为子网号subnet-id，而主机号host-id也就减少了相应的若干个位

凡是从其他网络发送给本单位的某个主机的IP数据报，仍然是根据IP数据报的目的网络号net-id，先找到连接在本单位上的路由器。然后该路由器在收到IP数据报后，再按照目的网络号和子网号找到目的子网。最后IP数据报就直接交付给目的主机。

#### 优点

1. 减少了IP地址的浪费
2. 使网络组织更加灵活
3. 更加便于维护和管理

### 子网掩码

我们需要用子网掩码（subnet mask）来判断主机或者目的主机是否进行了子网划分，它能帮我们找到IP地址中的子网部分。

规则：

- 子网掩码长度：32位
- 子网掩码左边一连串1，对应于网络号和子网号
- 子网掩码右边一连串0，对应主机号

这样我们通过分析它的子网掩码，再比对网络号和主机号的长度即可得到其子网号的位置。

我们定义：**IP地址 AND 子网掩码 = 网络地址**

即，将三级IP地址和三级IP地址的子网掩码进行逐位与运算，最后得到的就是子网的网络地址，实际上就是主机号对应的地址被消去全部改为0。

最后再对二进制地址进行点分十进制转换，即可得到我们熟悉的网络地址。

路由器在进行通信时，必须要把目的网络地址和子网掩码一起发送出去。若一个路由器连接在两个子网上，那么该路由器就拥有两个网络地址和子网掩码。

划分子网的方法分为**固定长度子网**和**变长子网**两种。

当采用固定长度子网时，所有子网的子网掩码都相同。采用划分子网增加了灵活性，却减少了能够连接在网络上的主机数。

## 超网CIDR

CIDR，即Classless Inter-Domain Routing，无分类编址

### 网络前缀

划分子网一定程度上解决了互联网的困难，但是1992年还是遇到了问题。B类地址即将分配完毕，路由表项目数急剧增长，IPv4的地址空间将全部耗尽。

于是我们开始使用变长子网掩码VLSM（Variable Length Subnet Mask），进一步提高了IP地址利用率。

在VLSM的基础上又进一步研究出无分类编址方法，它的正式名称是无分类域间路由选择CIDR（Classless Inter-Domain Routing）

#### CIDR的特点

CIDR消除了传统的A类、B类、C类地址以及划分子网的概念。它使用各种长度的“网络前缀”来代替分类地址中的网络号和子网号。至此，IP地址从三级编址（子网掩码）又回到了两级编址。即<网络前缀><主机号>

#### 无分类的两级编址

CIDR使用“斜线记法”，又称为CIDR记法，即在IP地址后面加一个斜线“/”，然后写上网络前缀所占的位数（对应于三级编址中子网编码的1的位数），例如：220.78.168.0/24

#### CIDR地址块

CIDR把网络前缀都相同的连续的IP地址组成“CIDR地址块”。例如128.14.32.0/20是一个地址块，共有2^12^个地址（因为斜线后面的20是网络前缀的位数，一共32位，故后112位是主机号）需要注意的是，全0或全1的主机号一般不使用

#### 路由聚合/route aggregation

一个CIDR地址块可以表示很多地址，这种地址的聚合就叫做**路由聚合**。它使得路由表中的一个项目可以表示上千个原来传统分类表示的路由。

路由聚合有利于减少路由器之间的鲈鱼信息交换，从而提高了互联网的性能。因此，路由聚合也被称为**构成超网（supernetting）**

最后，虽然CIDR废弃了子网，但是仍然使用“掩码”这个名词。但不同与子网掩码，比如对于/20地址块，它的掩码就是20个连续的1。

#### CIDR记法的其他形式

- 省略点分十进制中低位连续的0，比如10.0.0.0/10可简写为10/10
- 网络前缀的后面加一个星号\*，如0000101000\*，在星号之前是网络前缀，而星号\*表示IP地址中的主机号，可以是任意值。

#### 构成超网

前缀长度不超过23位的CIDR地址块都包含了多个C类地址。这些C类地址合起来就构成了超网。且CIDR地址块中的地址个数一定是2的整数幂。

网络前缀越短，其地址块所包含的网络个数就越多。而在三级结构的IP地址中，划分子网是使网络前缀变长。

CIDR的优点是可以根据需要分配地址块，从而更好的利用IPv4地址空间。

## IP数据报格式+分片与重组

\*注：以下内容默认为IPv4

### IP数据报的格式

IP数据报由首部和数据组成。首部的前一部分是**固定长度**，共**20字节**，是所有IP数据报必须有的格式。首部的固定部分后面是一些可选部分，长度可变。

![img](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/20231013084732.png?x-oss-process=style/blog)

每一行32位，对应四个字节。

#### IP数据报首部固定部分各字段

##### 版本

占4位，即IP协议的版本。目前版本号为4，即IPv4。

##### 首部长度

占4位，能够表示的最大长度是15个单位（一个单位4字节），因此IP首部长度最大值也只能是15个单位，即60字节。

##### 区分服务

一般情况下不使用，只有在使用区分服务（Diffserv）时才起作用。

##### 总长度

占16位，表示整个IP数据报的长度，即首部和数据之和的长度，数据报最大长度不得超过65535（2^16^-1）字节。**总长度必须不超过最大传送单元MTU。**因此实际传输中一般达不到65535字节，一般是一千字节，被以太网的传输能力限制（不能超过1500字节）。

##### 标识/identification

占16位，是一个计数器，用来产生IP数据报的标识。

##### 标志/flag

占3位，目前只有前两位有意义。标志字段的最低位是 MF (More Fragment)。MF=1 表示后面“还有分片”。MF=0 表示最后一个分片。标志字段中间的一位是 DF (Don't Fragment) 。只有当 DF=0 时才允许分片。

所谓分片，就是如果数据报过长，超出了以太网的传送限制，网络层就需要把数据报分成几份发送，以满足以太网的传输。

##### 片偏移

占13位，指出较长的分组在分片后，某片在原分组中的相对位置，片偏移以8个字节为偏移单位。

###### 例题

一数据报的总长度为 3820 字节，其数据部分的长度为 3800 字节（使用固定首部），需要分片为长度不超过 1420 字节的数据报片。因固定首部长度为 20 字节，因此每个数据报片的数据部分长度不能超过 1400 字节。于是分为 3 个数据报片，其数据部分的长度分别为 1400、1400 和 1000 字节。**原始数据报首部被复制为各数据报片的首部，但必须修改有关字段的值。**

数据报片1的片偏移为0/8=0

数据报片2的片偏移为1400/8=175

数据报片3的片偏移为12800/8=350

##### 生存时间

占8位，即为TTL（Time To Live），指示数据报在网络中可通过的路由器数的最大值。每通过一个路由器，TTL就减一，当TTL为0时，路由器将丢弃该数据报。

设置上限是为了防止数据报在网络中死循环。

##### 协议

占8位，指出次数据报携带的数据该使用何种协议，以便目的主机的IP层将数据部分上交给那个处理过程/进程。比如TCP、ICMP、UDP等。

##### 首部检验和

占16位，只检验数据报的首部，不检验数据部分。这里不采用CRC检验码而采取简单的计算方法，即16位二进制反码求和算法。

![img](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/20231013100355.png?x-oss-process=style/blog)

##### 源地址、目的地址

各占4字节。

#### IP数据报首部的可变部分

长度可变，1到40个字节不等，可以实现更多功能，如排错、测量以及安全等措施，但是也会变相的增加路由器处理数据包的开销，实际上这些选项很少被使用。

## 网络地址转换

### 为什么需要网络地址转换？

- ISP并不需要知道一个范围内的所有地址，很多情况下，知道一个地址指的是多个设备即可
- 透明性：可以更改本地设备的IP地址而不需要通知外部世界可以更改ISP而不需要更改本地设备的IP地址
- 安全性：本地网络内的设备并不能直接被外界网络访问或可见
- IP地址紧缺
- 互联网并不安全，不需要把所有主机接入互联网
- 对于一个机构内部的计算机通信，可以使用自行分配的IP地址。

### 本地地址与全球地址

本地地址：仅在机构内部使用的IP地址，可以由本机构自行分配，而不需要向互联网的管理机构申请

全球地址：全球唯一的IP地址，必须向互联网的管理机构申请。（域名？）

问题：在内部使用的本地地址有可能和互联网中的某个IP地址重合，这样就会出现地址的二义性问题。

解决：RFC 1918中指明了一些**专用地址**。专用地址只能用作本地地址而不能用作全球地址。在互联网中的所有路由器对目的地址是专用地址的数据报一律不进行转发。

**三个专用IP地址块：**

1. 10.0.0.0到10.255.255.255

   A类，或记为10.0.0.0/8，又称为24位块

2. 172.16.0.0到172.31.255.255

   B类，或记为172.16.0.0/12，又称为20位块

3. 192.168.0.0到192.168.255.255

   C类，或记为192.168.0.0/16，又称为16位块

采用这样的专用IP地址的互联网络称为**专用互联网**或**本地互联网**，或者就叫**专用网**。

因为这些专用地址仅在本机构内部使用，专用IP地址也叫作**可重用地址**（reusable address）

### NAT - Network Address Translation

基于以上原因，1994年提出了NAT的概念。如果在本地网络的主机要和互联网的其他主机进行通信，我们一般采用网络地址转换NAT。

NAT实际上是本地网络和互联网中间的媒介。需要在专用网连接到互联网的路由器上安装NAT软件，装有NAT软件的路由器叫做NAT路由器，它至少有一个有效的外部全球IP地址。这样使用本地地址的主机在和外界通信时，都要在NAT路由器上将本地地址转换成全球IP地址，才能和互联网连接。

### NAT的两种实现方式

- NAT：纯粹的地址转换，一般不使用

- NAPT/Network Address and Port Translation

  利用地址加端口进行转换，现实中一般都是用这种，但我们一般都叫NAT，不加上“端口”这个限定。

#### NAT的实现

![img](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/20231013103541.png?x-oss-process=style/blog)

内部主机A用本地地址IP~A~和互联网上的主机B通信，必须经过NAT路由器。NAT路由器将数据报源地址IP~A~转换为全球地址IP~G~，并把转换结果保存在NAT地址转换表中，目的地址保持不变，然后发送到互联网。在接收到互联网主机B发回的数据报时，NAT再将目的地址IP~G~转换为IP~A~发送给内部主机A。

这样带来了两个后果：

- 当NAT路由器具有n个全球地址时，专用网内最多可以同时有n台专用机接入互联网，这样就可以使专用网内数量较多的主机轮流使用NAT路由器数量有限的全球IP地址。

  但是缺点是不能保证很多台主机同时上网。

- 通过NAT路由器的通信必须由专用网内的主机发起。专用网内部不能充当服务器用，因为互联网上的客户不知道专用网内服务器的IP地址。

  这个缺点NAT无法解决。

#### NAPT的实现

为了解决以上两个问题，我们提出了NAPT，了解一下传输层-端口号的概念。

NAT路由器只需要一个全球IP地址，不通过IP地址来区分不同的本地源IP地址，而通过NAT路由器上的端口号来实现。

NAT路由器发出的数据报转换为：source IP addr, port #) -> (NAT IP addr, new port #)

所有从外界发回来的数据报也会使用(NAT IP addr, new port #)

在NAT地址转换表中，将记录每一个映射对，接收到数据报后经过映射转换再发送给正确的主机。

### NAT（&NAPT）总结

NAPT采用端口号区分本地网内的不同主机，端口号在传输层分组中，占用16bit。因此，即使只使用一个全球IP地址，也能同时连接超过六万台本地主机。

NAT是“有争议性”的、“临时”的解决手段

路由器应至多只处理第三层；

端口号是第四层的地址短缺应由IPv6彻底解决，而不应该让NAT作临时解决，违背了端对端原则（end-to-end argument）

网络不应该修改分组的内容！应该由端系统来做这件事情例如，p2p应用，由应用程序本身来做这件事情，而不是由网络来做

NAT后的主机不能同时作为服务器向外提供服务

## IPv6

IPv4的32位地址已经耗尽，于是决定采用具有更大地址空间的新版本IP，即IPv6

IPv6 仍支持**无连接的传送**，但将协议数据单元 PDU（数据报） 称为**分组**。为方便起见，本书仍采用数据报这一名词

主要变化如下：

1. 更大的地址空间，从32位到了128位
2. 拓展的地址层次结构
3. 灵活的首部格式，IPv6定义了许多可选的拓展首部
4. 改进的选项。IPv6允许数据报包含有选项的控制信息，将选项放进有效载荷中
5. 允许协议继续扩充
6. 支持即插即用（自动配置）
7. 支持资源预分配。IPv6支持实时视象。
8. IPv6首部改成8字节对齐，首部长度必须是8字节的整数倍，原来的IPv4首部是4字节对齐。

### IPv6的形式

IPv6主要分为两部分：基本首部和有效载荷。其中基本首部占固定的40字节，剩下的有效载荷不超过65535字节，包活拓展首部和数据部分。

首部的变化主要有以下改变：

- 取消了首部长度字段，IPv6的首部长度为固定的40字节
- 取消了服务类型字段
- 取消了总长度字段，改用有效载荷字段
- 把TTL改为跳数限制字段
- 取消了协议字段，改为下一个首部字段
- 取消了检验和字段
- 取消了选项字段，改用扩展首部来实现

#### IPv6首部固定部分各字段

##### 版本

占4位，总是为6。

##### 通信量类/traffic class

8位，为了区分不同得到IPv6数据报的类型和优先级。

##### 流标号/flow label

20位，属于一个流的数据报都拥有相同的流标号。

##### 有效载荷长度/payload length

16位，指明了非固定首部部分的长度，最大值为64KB。

##### 下一个首部/next header

8位，相当于IPv4的协议字段或可选字段。

##### 跳数限制/hop limit

8位，和TTL大致相同。

##### 源地址

128位，是发送数据站的IP地址。

##### 目的地址

128位，是数据报接收站的IP地址。

**IPv6不要求记住首部字段意义，但要求记住IPv4首部。**

### IPv6的地址

1. 单播/unicast：传统的点对点通信
2. 多播/multicast：一对多点的通信
3. 任播/anycast：IPv6新增加的类型。任播的目的站是一组计算机，但是数据报的交付只交给其中一台，通常是目的最近的那一个。

#### 结点与接口

IPv6将实现IPv6的主机和路由器统称为**结点**。一个节点可能有多个和链路连接的接口。IPv6地址就是分配给上面的接口的。

一个接口可以有多个单播地址，任何一个单播地址都可以用来当做到达该结点的目的地址。

#### 冒号十六进制记法/colon hexadecimal notation/colon hex

IPv6允许将其地址每十六位用十六进制表示，各个值之间用冒号分隔，并且允许省略数字前面的0，例如：`68E6:8C64:FFFF:FFFF:0:1180:960A:FFFF`。

冒号十六进制可以允许**零压缩**，即一连串连续的零可以用一对冒号所替代。

例如`FF05:0:0:0:0:0:0:B3`，可压缩为`FF05::B3`。

在任一地址中只能使用一次零压缩。

冒号十六进制仍可采用点分十进制记法的后缀，这种结合在IPv4转IPv6时很有用。

例如`0:0:0:0:0:0:128.10.2.1`，可压缩为`::128.10.2.1`。

CIDR的斜线表示法仍然可用。

如60位的前缀`12AB00000000CD3`，可以记为：`12AB:0000:0000:CD30:0000:0000:0000:0000/60`。

#### 地址分类

| 地址类型     | 二进制前缀                          |
| ------------ | ----------------------------------- |
| 未指明地址   | 00...0（128位），可记::/128         |
| 环回地址     | 00..1（128位），可记为::1/128       |
| 多播地址     | 1111111（8位），可记为FF00::/8      |
| 本地链路地址 | 1111111010（10位），可记为FE80::/10 |
| 全球单播地址 | 除上述地址外，所有其他的二进制地址  |

##### 未指明地址

这个地址只能为还没有分配到一个标准IP地址的主机当做源地址使用，这类地址仅此一个。

##### 环回地址

作用与IPv6的环回地址一样，这类地址也是仅此一个。

##### 多播地址

功能与IPv4的相同。

##### 本地链路单播地址/Link-Local Unicast Address

有些单位的网络使用TCP/IP协议，但没有连接到互联网上。这样连接的主机都可以用这种本地地址进行通信，但不能和互联网其他地址通信。

##### 全球单播地址

使用最多的一类IPv6地址，IPv6单播地址的划分方法十分灵活。

![image-20231020091322330](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20231020091322330.png?x-oss-process=style/blog)

#### 从IPv4到IPv6过渡

主要使用两种策略：双协议栈和隧道技术。

##### 双协议栈/dual stack

指的是双协议栈的主机或者路由器同时拥有两种地址：一个IPv6地址和一个IPv4地址。主机和IPv6主机通信就采取IPv6地址，和IPv4主机通信就采取IPv4地址。主机一般通过DNS返回的地址类型来确定使用哪种地址进行通信。

##### 隧道技术

隧道技术就是在IPv6数据报将要进入IPv4网络时，将IPv6数据报封装为IPv4数据报，整个的IPv6数据报变成了IPv4数据报的数据部分。等IPv4数据报离开IPv4网络隧道时，再将数据部分/IPv6数据报交给主机的IPv6协议栈。

## 路由协议/算法

路由协议的目的是如何选择从起点到终点经过路由器的最佳路径。路由协议不关心如何在主机中传送数据，它只研究路由器之间的最佳路径。

### 基本概念

#### 理想路由算法

- 算法是正确且完整的
- 算法在计算上应该简单
- 算法能适应通信量和网络拓扑的变化，也就是说要有自适应性
- 算法具有稳定性
- 算法是公平的
- 算法是最佳的

#### “最佳路由”

- 不存在一种绝对的最佳路由算法
- 最佳路由算法只是一种特定条件下的最优解
- 最佳路由算法非常复杂，因为有很多变量在开始时不能全部知道。
- 静态路由选择策略：非自适应路由选择，开销较小，但不能及时适应网络变化
- 动态路由选择策略：自适应路由选择，较好的适应网络状态的变化，但开销较大。

### 分层次的路由选择协议

#### 内部网关协议/IGP

一个自治系统内部使用的路由选择协议。

内部网关协议用的最多的是RIP和OSPF协议。

#### 外部网关协议/EGP

若源站和目的站在不同的自治系统中，当数据报传到系统边界时，就需要一种协议将路由选择信息传入另一个自治系统中，这就是外部网关协议EGP。

目前用的最多的外部网关协议是BGP-4.

### 路由算法的分类

#### 链路状态算法

所有路由器知道完整的拓扑结构与路径的距离和开销。

使用Dijkstra最短路径算法，详细算法参见其他资料：

[dijkstra算法 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/72120630)

[Dijkstra算法详解 通俗易懂 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/338414118)

#### 距离向量算法

路由器只知道和自己相邻的其他路由器的存在与距离成本信息。

使用Bellman-Ford等式（动态规划思想）

#### 算法对比

|            | 链路状态算法                                                 | 距离向量算法                                                 |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 消息复杂度 | n个节点，E条线路，需要发送O(nE)条消息                        | 消息只在相邻节点中传播，数量不定                             |
| 收敛速度   | O(n^2)，复杂度确定                                           | 收敛时间不定，可能有路由环路，无穷计数等问题                 |
| 健壮性     | 可能会广播错误的**链路**成本，且每个节点只会计算自己的转发表 | 可能会广播错误的**路径**成本，每个节点的转发表都会被其他节点所使用，所以错误可能会在网络中逐渐传播 |

## 内部网关协议 RIP协议

RIP/Routing Information Protocol路由信息协议是一种分布式的，**基于距离向量**的路由选择协议，是内部网关协议IGP中最先得到广泛使用的协议。

### 距离的定义

- 从一个路由器到直接连接的网络距离定义为1，到非直接连接的网络距离定义为所经过的路由器数目加一。
- RIP中的距离就是“跳数”（hop count），因为每经过一个路由器跳数就加一。
- 这里的距离其实就是“最短距离”。
- RIP只允许一条路径最多包含15个路由器。故RIP协议只能在小型网络中使用。
- RIP无法在两个网络中使用多条路由，因为RIP只选择经过路由器数量最少的路由。

### 特点

- 仅和相邻路由器交换信息（距离向量算法）
- 交换信息就是自己的路由表（距离向量算法）
- 按固定的时间交换路由信息，防止交换的路由表是错误的（距离向量算法）

### 报文格式

RIP2协议是被包含在UDP协议中在网络层进行传输的。结构图如下。

![](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20231027110212473.png?x-oss-process=style/blog)

这些信息统称为路由信息（20字节/路由），可以重复出现，最多不超过25个。

- RIP2报文由首部和路由部分组成。
- 地址族标识符字段用来标志所使用的地址协议。
- 路由标记填入自治系统的号码，防止RIP使用自治系统外的路由选择信息。
- 在后面就是网络地址，子网掩码，和下一跳的路由地址以及距离。

### 优缺点

#### 优点

实现简单，开销小。

#### 缺点

1. 限制了网络的规模，只能在15个路由器之间使用。
2. 因为路由器之间交换路由表是路由器中的完整路由表，网络规模扩大会带来开销的增加（实际上也增加不了多少）
3. “坏消息传的慢”，更新过程收敛时间太长。

## OSPF协议

OSPF的原理很简单，但是实现却有点复杂。

### 特点

- “开放”，不受某一家厂商克制，而是公开发表的。
- “最短路径优先”，使用了Dijkstra提出的最短路径算法SPF。
- 采用分布式的链路状态协议。
- 在实际使用中，使用**洪泛法**向自治系统中的所有路由器发送信息。发送的信息是与本路由器相邻的所有路由器的链路状态，这只是路由器知道的部分信息。
- “链路状态”是说明本路由器和哪些路由器相邻以及该链路的“度量”（metric）。
- 只有链路状态变化时，路由器才采用洪泛法向所有路由器发送此信息，节省了流量。

#### 链路状态数据库/link-state database

由于各路由器之间频繁的交换路由信息，最后所有的路由器都能建立一个链路状态数据库。其实就是全网的拓扑结构图，这在全网的范围内是一致的（称为链路状态数据库是同步的）。且OSPF的链路状态数据库能够较快的更新，OSPF的更新过程收敛快是它的一个重要优点。

#### 区域/area

为了使OSPF能够用于规模很大的网络，OSPF将一个自治系统再划分为若干个更小的范围，称为**区域**（就是在中间人工的添加了一个层次）。每一个区域都有一个32位的区域标识符（用点分十进制表示）。

但是区域也不能太大，最好不超过200个路由器。

##### 划分区域

划分区域的好处就是利用洪泛法交换的链路信息状态局限于每个区域而不是整个自治系统，这样减少了网络上的通信量。

在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其他区域的网络拓扑情况。

OSPF使用**层次结构的区域划分**，在上层的区域叫做**主干区域/backbone area**。主干区域的标识符规定为0.0.0.0，其作用是连通其他在下层的区域。

#### 直接使用IP数据发送

OSPF不使用UDP而直接使用IP数据报发送。这样的数据报很短，可以减少路由信息的通信量，且不必将过长的数据分片传输。

但是分片传输的数据只要丢失一个，就无法组装成原来的数据报，整个数据报就必须重传。

#### 分组类型

- 问候分组
- 数据库描述分组
- 链路状态请求分组
- 链路状态更新分组/用洪泛法对全网更新路由状态
- 链路状态确认分组

基本操作如下。

![image-20231103091602726](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20231103091602726.png?x-oss-process=style/blog)

#### 其他

OSPF对不同的链路可以根据IP分组的不同服务类型TOS而设置成不同的代价。也就是说，OSPF可以根据不同类型的业务计算出不同的路由。如果到达同一个目的有多条相同代价的路径，就可以将通信量分配给这几条路径，达到**多路径间的负载平衡**（这点和RIP协议大相径庭，OSPF要做的更好）。

所有在OSPF路由器之间交换的分组都具有鉴别的功能，且支持可变长度的子网划分和无分类编址CIDR。

每一个链路状态都带上一个32位的序号，序号越大状态越新。

OSPF还规定每隔一段时间（比如30分钟）就刷新一次数据库中的链路状态。

因为OSPF每一个路由器的链路状态只涉及到与其相邻的路由器状态，和互联网规模没有直接关系。所以当互联网规模很大时，OSPF协议要明显优于RIP。

OSPF没有坏消息传播得慢”的问题。

## 外部网关协议

### BGP协议

BGP是不同自治系统路由器之间的交换路由信息的协议。

#### 使用环境

由于互联网规模太大，一条路径通过几个不同的AS（自治系统）时，计算出“最佳路由”是不太可能的。比较合理的做法是在AS间交换“可达性”信息。于是，BGP边界网关协议只是力求找到一条**比较好**的路由（不循环就算成功），而不是最佳路由。

#### 发言人

每一个自治系统的管理员都至少要选择一个路由器作为该自治系统的“BGP发言人/speaker”。

一个BGP发言人与其他自治系统中的BGP发言人要交换路由信息，就必须先建立**TCP连接**，然后在此连接的基础上建立**BGP会话/session**，利用此会话交换路由信息。使用TCP连接交换信息的两个发言人，互为对方的**邻站/neighbor**或**对等站/peer**。

BGP交换的网络可达性信息就是**要到达某个网络所要经过的一系列AS**。当各个发言人互相交换了可达性信息后，发言人就可以根据所采用的策略来从收到的路由信息中选择到达各AS的较好路由。

例图如下。

![image-20231103094323847](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20231103094323847.png?x-oss-process=style/blog)

#### 特点

BGP协议交换路由信息的节点数量级是自治系统数的量级，这笔自治系统中的网络数少很多。且每一个BGP发言人数量很少，使得自治系统之间的路由选择不过于复杂。

BGP支持CIDR。

在BGP刚刚运行时，要和邻站交换整个路由表。而之后在发生变化时只更新变化的部分，这样做对节省网络带宽和减少路由器处理开销都有好处。

## ICMP协议

为了更有效的转发IP数据报，在网络层采取了**网络控制报文协议ICMP/Internet Control Message Protocol**。

ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告（Ping 的时候貌似发送的就是这个）。但是ICMP报文并不是高层协议，而是IP层的协议。ICMP的报文被封装在IP数据报中。

### 格式

![image-20231103095327126](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20231103095327126.png?x-oss-process=style/blog)

### 种类

有两种，即**差错检验报文**和**询问报文**。

ICMP前4个字节是统一的格式，共有三个字段：**类型、代码、检验和**。接着4个字节的内容与ICMP的类型有关。

### 差错报告报文

共有4种。

- 终点不可达
- 超时
- 参数问题
- 改变路由（重定向/Redirect）

内容如图所示。

![image-20231103095909320](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20231103095909320.png?x-oss-process=style/blog)

### 询问报文

有两种。

- 回送请求和回答报文
- 时间戳请求和回答报文

### 应用举例

#### PING/Packet Internet Groper

Ping用来测试两个主机的连通性，使用了ICMP的回送请求和回答报文。它是应用层直接使用网络层ICMP的例子，没有经过运输层的TCP或者UDP。

#### Traceroute

在Windows中这个命令时tracert，用来跟踪一个分组从源点到终点的路径。利用IP数据报中的TTL字段和ICMP时间超过差错报告实现从源点到终点的路径的跟踪。

## 运输层

运输层属于面向通信部分的最高层，也是用户功能中的最低层。只有位于网络边缘部分的主机的协议栈才有运输层。

我们引入“逻辑通信”这个概念，实际上在前面也有介绍过。她的意思是“好像是这样通信，但事实上并非是这样”。比如网络层之间传输数据，可以直接看成两台主机之间的通信而忽略其下的链路层传输。而在运输层中，这种说法还不够明确，实际上两台主机之间进行通信应该是“端到端”的通信，也就是主机上进程之间的通信。我们也把这些通信叫为“计算机之间的通信”，但是和主机之间通信的含义并不一样。

运输层向高层的用户屏蔽了底层信息，让主机之间通信看起来好像存在一条通路使得进程之间直接进行通信。

### UDP和TCP

| UDP                                                          | TCP                                                        |
| ------------------------------------------------------------ | ---------------------------------------------------------- |
| 无连接的协议，提供无连接服务。                               | 面向连接的协议，面向连接的服务。                           |
| 传送的协议数据单元TPDU是UDP报文或用户数据报。                | 其TPDU是TCP报文。                                          |
| 支持单播、多播、广播。                                       | 支持点对点单播，不支持多播、广播                           |
| 不提供可靠服务。                                             | 保证服务可靠                                               |
| 简单，适用于很多应用。适用于对数据可靠性要求不高，或者数据大小较小的应用。如多媒体应用等。 | 复杂。适用于大多数应用，如：万维网、电子邮件、文件传输等。 |

![image-20231110000751387](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20231110000751387.png?x-oss-process=style/blog)

还有两点需要强调：

1. 运输层的 UDP 用户数据报与网际层的IP数据报有很大区别。IP 数据报要经过互连网中许多路由器的存储转发，而UDP 用户数据报是在运输层的端到端抽象的逻辑信道中传送的。（这里我也有点没看懂）
2. TCP 报文段是在运输层抽象的端到端逻辑信道中传送，这种信道是可靠的全双工信道。但这样的信道却不知道究竟经过了哪些路由器，而这些路由器也根本不知道上面的运输层是否建立了 TCP 连接。因为被抽象掉了吧。

#### 运输层的端口

运行在计算机中的进程是用**进程标识符**来标志的。

但运行在应用层的各种应用进程却不应当让计算机操作系统指派它的进程标识符。这是因为在互联网上使用的计算机的操作系统种类很多，而不同的操作系统又使用不同格式的进程标识符。

为了使运行不同操作系统的计算机的应用进程能够互相通信，就必须**用统一的方法**对 TCP/IP 体系的应用进程进行标志。 

这里就有几个问题需要被解决：

- 由于进程的创建和撤销都是动态的，发送方几乎无法识别其他机器上的进程/如何识别其他机器的进程。
- 有时我们会改换接收报文的进程，但并不需要通知所有发送方/如何动态的更换接收报文的进程。
- 我们往往需要利用目的主机提供的功能来识别终点，而不需要知道实现这个功能的进程/如何识别进程终点。

为了解决这些问题，我们引入了**端口号**的概念。

#### 端口号/protocol port number

解决这个问题的方法就是在运输层使用**协议端口号 (protocol port number)**，或通常简称为**端口 (port)**。

虽然通信的终点是应用进程，但我们可以把端口想象是通信的终点，因为我们只要把要传送的报文交到目的主机的某一个合适的目的端口，剩下的工作（即最后交付目的进程）就由 TCP 来完成。

端口用一个 16 位端口号进行标志，允许有65,535个不同的端口号。端口号只具有本地意义，即端口号只是为了标志本计算机应用层中的各进程。在互联网中，不同计算机的相同端口号是没有联系的。

也就是说，两个计算机中的进程要互相通信，不仅必须知道对方的端口号（为了找到对方计算机中的应用进程） ，而且还要知道对方的 IP 地址（为了找到对方的计算机）。

##### 两大类端口号

一般来说，将端口号分为服务器使用端口和客户端使用的端口。

###### 服务器端使用的端口号

1. 熟知端口，数值一般为 0 ~ 1023。
2. 登记端口号，数值为 1024 ~ 49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在 IANA 登记，以防止重复。

###### 客户端使用的端口号

1. 又称为短暂端口号，数值为 49152 ~ 65535，留给客户进程选择暂时使用。
2. 当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。 

![](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20231117132354258.png?x-oss-process=style/blog)

##### 硬件端口和软件端口

这是两种不同的概念。

在协议栈层间的抽象的协议端口是软件端口。路由器或交换机上的端口是硬件端口。

硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层的各种协议进程与运输实体进行层间交互的一种**地址**。 

### UDP协议

接下来我们来介绍用户数据报协议UDP。

#### 概述

UDP 只在 IP 的数据报服务之上增加了很少一点的功能：复用和分用的功能差错检测的功能。它主要有以下几个特点：

1. 无连接。发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。
2. 使用最大努力交付。即不保证可靠交付，因此主机不需要维持复杂的连接状态表。
3. 面向报文。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。UDP 一次交付一个完整的报文。
4. 没有拥塞控制。因此网络拥塞不会使源主机发送速率降低，适合多媒体通信。
5. 支持一对一、一对多、多对一和多对多的交互通信。
6. 首部开销小。比起TCP的20个字节，UDP的首部只有8字节。

#### 面向报文

在发送方，UDP对于应用程序交付给他的报文不做额外处理，添加首部后就直接向下交给IP层，只是保留了报文的边界。应用层交付给UDP多长的报文，UDP就照样会发送，即一次发送一个报文。

在接收方，UDP对于IP层交上来的数据报只是简单的去除首部就原封不动的上交给应用进程，**一次性交付一个完整的报文**。

对于应用程序，必须要选择**合适长度大小**的报文。

- 报文太长，UDP把它交给IP层发送时，IP层可能要进行分片，这会降低传送的效率。
- 报文太短，UDP把它交给IP层后，会使得IP层数据报首部的相对长度太大，这也降低了效率。

#### UDP的首部格式

用户数据报 UDP 有两个字段：数据字段和首部字段。首部字段有 8 个字节，由 4 个字段组成，每个字段都是 2 个字节。 分别是：源端口、目的端口、长度、检验和。

当运输层从 IP 层收到 UDP 数据报时，就根据首部中的目的端口，把 UDP 数据报通过相应的端口，上交给最后的终点——应用进程。

长度指UDP数据报整体的长度。

检验和计算时，需要临时把12个字节的“伪首部”和UDP用户数据报连接在一起计算。

![image-20231117134838024](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20231117134838024.png?x-oss-process=style/blog)

### TCP协议

这一小节主要介绍传输控制协议 TCP协议。

#### 主要特点

TCP 是**面向连接**的运输层协议，在无连接的、不可靠的 IP 网络服务基础之上提供**可靠交付**的服务。为此，在 IP 的数据报服务基础之上，增加了保证可靠性的一系列措施。

- TCP 是面向连接的运输层协议。
- 每一条 TCP 连接只能有两个端点 (endpoint)，每一条 TCP 连接**只能是点对点的**（一对一）。 
- TCP 提供**可靠交付**的服务。
- TCP 提供**全双工**通信。
- **面向字节流**
  - TCP 中的“流”(stream) 指的是流入或流出进程的字节序列。
  - “面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块，但 TCP 把应用程序交下来的数据看成仅仅是一连串无结构的字节流。

所谓的面向流的概念，是指TCP 不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系。但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样。

TCP 不关心应用进程一次把多长的报文发送到 TCP 缓存。TCP 对连续的字节流进行分段，形成 TCP 报文段。

##### 注意

TCP 连接是一条**虚连接**而不是一条真正的物理连接。

TCP 对应用进程一次把多长的报文发送到 TCP 的缓存中是不关心的。

TCP 根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节（UDP 发送的报文长度是应用进程给出的）。

TCP 可把太长的数据块划分短一些再传送。TCP 也可等待积累有足够多的字节后再构成报文段发送出去， 即缓存发送。

### TCP的连接

在每一个TCP连接中都有两个端点（因为TCP只能实现单一的端对端通信），TCP连接的端点叫做套接字/socket或插口。

套接字 socket = （IP地址:端口号），例如（192.169.1.20:2028）。每一条TCP连接唯一的被一对套接字所确定，即TCP 连接 ::={socket1，socket2} = {(IP1:port1),(IP2::port2)}

#### TCP IP Sokcet的关系

TCP 连接就是由协议软件所提供的一种抽象。TCP 连接的端点是个很抽象的套接字，即（IP 地址：端口号）。同一个 IP 地址可以有多个不同的 TCP 连接。同一个端口号也可以出现在多个不同的 TCP 连接中。

#### 关于Socket

应用编程接口  API  称为 socket API, 简称为 socket。socket API 中使用的一个函数名也叫作 socket。调用 socket 函数的端点称为 socket。调用 socket 函数时其返回值称为 socket 描述符，可简称为 socket。在操作系统内核中连网协议的 Berkeley 实现，称为 socket 实现。

### 可靠传输的工作原理

理想的传输条件有以下两个特点：

1. 传输信道不产生差错。
2. 不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据。

在这样的理想传输条件下，不需要采取任何措施就能够实现可靠传输。然而实际的网络都不具备以上两个理想条件，因为网络本身是不可靠的。必须使用一些可靠传输协议，在不可靠的传输信道实现可靠传输。

#### 停止等待协议

“停止等待”就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组，类似于与别人聊天每说一句话就询问对方听见没有，是一个很天真的协议。

全双工通信的双方既是发送方也是接收方。为了讨论问题的方便，我们仅考虑 A 发送数据，而 B 接收数据并发送确认。因此 A 叫做发送方，而 B 叫做接收方。

##### 无差错情况

A 发送分组 M1，发完就暂停发送，等待 B 的确认 (ACK)。B 收到了 M1 向 A 发送  ACK。A 在收到了对 M1 的确认后，就再发送下一个分组  M2。

![image-20231110084535335](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20231110084535335.png?x-oss-process=style/blog)

##### 出现差错

在接收方 B 会出现两种情况：

1. B 接收 M1 时检测出了差错，就丢弃 M1，其他什么也不做（不通知 A 收到有差错的分组）。
2. M1 在传输过程中丢失了，这时 B 当然什么都不知道，也什么都不做。

在这两种情况下，B 都不会发送任何信息。但A都必须重发分组，直到B正确接收为止，这样才能实现可靠通信。

###### 问题一

但是在B什么都不做的情况下，A要如何知道需要重传M1呢？停止等待协议给出的办法是超时重传。

超时重传让A为每一组发送的分组设置了一个超时计时器。如果在该计时器过期之前收到了确认ACK，就撤销这个计时器，继续发送下一个分组；否则认为该分组发送错误或者丢失，就重发该分组。

###### 问题二

若分组正确到达B，但B回送的确认丢失或延迟了，A未收到B的确认，会超时重发。B 可能会收到重复的 M1 。B如何知道收到了重复的分组，需要丢弃呢？协议给出了编号的方法。

A为每一个发送的分组都进行编号。若B收到了编号相同的分组，则认为收到了重复分组，丢弃重复的分组，并回送确认。

B为发送的确认也进行编号，指示该确认是对哪一个分组的确认。

A根据确认及其编号，可以确定它是对哪一个分组的确认，避免重发发送。若为重复的确认，则将其丢弃。

###### 问题三

若 B 所发送的对 M1 的确认丢失了，那么 A 在设定的超时重传时间内不能收到确认，但 A 并无法知道：是自己发送的分组出错、丢失了，或者 是 B 发送的确认丢失了。因此 A 在超时计时器到期后就要重传 M1，以此来确认丢失或者确认迟到。

如果B收到了重复的分组，那么它将采取两种行动：

1. 第一，丢弃这个重复的分组 M1，不向上层交付。
2. 第二，向 A 发送确认。不能认为已经发送过确认就不再发送，因为 A 之所以重传 M1 就表示 A 没有收到对 M1 的确认。

假如传输过程中没有出现差错，但 B 对分组 M1 的确认迟到了。

那么A 会收到重复的确认。对重复的确认的处理很简单：收下后就丢弃。B 仍然会收到重复的 M1，并且同样要丢弃重复的 M1，并重传确认分组。

注意

- 在发送完一个分组后，必须暂时保留已发送的分组的副本，以备重发。分组和确认分组都必须进行编号。
- 超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些。 因为如果设置的太短，数据还在发回来之前就被确认为丢失或者失败，A就会不断发送数据陷入死循环。

##### 归纳

1. 停止等待。发送方每次只发送一个分组。在收到确认后再发送下一个分组。
2. 编号。对发送的每个分组和确认都进行编号。
3. 自动重传请求。发送方为每个发送的分组设置一个超时计时器。若超时计时器超时，发送方会自动重传分组。
4. 简单，但信道利用率太低。

#### 信道利用率

停止等待协议的优点是简单，但是缺点是信道利用率太低。

![image-20231110091642949](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20231110091642949.png?x-oss-process=style/blog)

为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用**流水线传输**。流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。这样可使信道上一直有数据不间断地传送。由于信道上一直有数据不间断地传送，这种传输方式可获得很高的信道利用率。 

#### 自动重传请求ARQ

通常A总是可以收到确认，如果A总是不断的重传数据，说明通信线路太差。

通过使用如上重传机制，我们可以在不可靠的网络上实现可靠的通信。我们把这种可靠传输协议称为自动重传请求/Automatic Repeate reQuest。意思是重传请求时自动进行的，接收方不需要做出任何请求让对方重传某个出错的分组。

![image-20231110092941558](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20231110092941558.png?x-oss-process=style/blog)

基本思想如下：

发送方一次可以发出多个分组。使用滑动窗口协议控制发送方和接收方所能发送和接收的分组的数量和编号。每收到一个确认，发送方就把发送窗口向前滑动。接收方一般采用累积确认的方式。采用回退N（Go-Back-N）方法进行重传。

滑动窗口的概念如下：

![image-20231110094113052](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20231110094113052.png?x-oss-process=style/blog)

##### 累积确认

接收方一般采用累积确认的方式。即不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认。这样就表示：到这个分组为止的所有分组都已正确收到了。

- 优点：容易实现，即使确认丢失也不必重传。
- 缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。

##### Go-back-N（回退 N）

如果发送方发送了前 5 个分组，而中间的第 3 个分组丢失了。这时接收方只能对前两个分组发出确认。发送方无法知道后面三个分组的下落，而只好把后面的三个分组都再重传一次。这就叫做 Go-back-N（回退 N），表示需要再退回来重传已发送过的 N 个分组。

可见当通信线路质量不好时，连续 ARQ 协议会带来负面的影响。 

### TCP报文段的首部格式

TCP 报文段首部的前 20 个字节是固定的，后面有 4n 字节是根据需要而增加的选项 (n 是整数)。因此 TCP 首部的最小长度是 20 字节。

具体格式图解如下

![image-20231117083644231](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20231117083644231.png?x-oss-process=style/blog)

#### 源端口和目的端口字段

各占 2 字节。端口是运输层与应用层的服务接口。运输层的复用和分用功能都要通过端口才能实现。

#### 序号字段

占 4 字节。TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。 

比如有：

报文段 1 序号 = 1001 （数据字节序号：1001 ~ 2000）

报文段 2 序号 = 2001 （数据字节序号：2001 ~ 3000）

……

#### 确认号字段

占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。 

#### 数据偏移

即首部长度，占 4 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。“数据偏移”的单位是 32 位字（以 4 字节为计算单位）。 

#### 保留字段

占 6 位，保留为今后使用，但目前应置为 0。

#### 保留字段

占 6 位，保留为今后使用，但目前应置为 0。

#### 确认 ACK 

只有当 ACK =1 时确认号字段才有效。当 ACK =0 时，确认号无效。 

#### 推送 PSH (PuSH) 

接收 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。 

#### 复位 RST (ReSeT) 

当 RST=1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。

#### 同步 SYN 

同步 SYN = 1 表示这是一个连接请求或连接接受报文。 

#### 终止 FIN (FINish)

 用来释放一个连接。FIN=1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。 

#### 窗口字段 

 占 2 字节，用来让对方设置发送窗口的依据，单位为字节。

#### 检验和

占 2 字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。

#### 紧急指针字段

占 16 位，指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）。 

#### 选项字段 

 长度可变。TCP 最初只规定了一种选项，即最大报文段长度 MSS。MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节。”

##### MSS (Maximum Segment Size)

一个选项字段，是 TCP 报文段中的数据字段的最大长度。数据字段加上 TCP 首部才等于整个的 TCP 报文段。所以，MSS是“TCP 报文段长度减去 TCP 首部长度”。

#### 填充字段 

 这是为了使整个首部长度是 4 字节的整数倍。

### TCP 可靠传输的实现

#### 以字节为单位的滑动窗口

因为自动重传的效率太低，所以TCP采用滑动窗口的方式来传输数据，使用流水线传输和滑动窗口协议实现高效、可靠的传输。

注意，TCP的滑动窗口是**以字节为单位**，而非报文段。

发送方 A 和接收方 B 分别维持一个发送窗口和一个接收窗口。发送窗口表示：在没有收到确认的情况下，可以连续把窗口内的数据全部发送出去。接收窗口表示：只允许接收落入窗口内的数据。

根据 B 给出的窗口值，A 构造出自己的发送窗口。发送窗口表示：在没有收到 B 的确认的情况下，A 可以连续把窗口内的数据都发送出去。 发送窗口里面的序号表示允许发送的序号。窗口越大，发送方就可以在收到对方确认之前连续发送更多的数据，因而可能获得更高的传输效率。

![image-20231117090234811](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20231117090234811.png?x-oss-process=style/blog)

其中，允许发送的部分又可以分为两种：已发送但未收到确认和允许发送但未发送。当所有允许发送窗口内的字节都已经发送且收到确认，发送窗口就可以前移滑动发送下一段字节流。

对于接收窗口，则负责接收允许接收的部分并给出确认信号。如果未按序收到字节，就先存下已收到的信息等待缺少数据的到达，或者直接丢弃未按序的数据等待重新发送，这一点TCP没有给出明确规定。

如果发送窗口内的序号都已用完，但是还是没有收到确认，就必须停止发送。

#### 发送缓存

发送方的应用进程把字节流写入TCP的发送缓存，接收方的应用进程从TCP的接受缓存中读取字节流。

发送缓存用来暂时存放：发送应用程序传送给发送方 TCP 准备发送的数据；TCP 已发送出但尚未收到确认的数据。接收缓存用来暂时存放：按序到达的、但尚未被接收应用程序读取的数据；不按序到达的数据。

这里要强调三点：

1. A 的发送窗口并不总是和 B 的接收窗口一样大（因为有一定的时间滞后）。
2. TCP 标准没有规定对不按序到达的数据应如何处理。通常是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程。
3. TCP 要求接收方必须有累积确认的功能，这样可以减小传输开销。 

#### 发送确认

接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上。但请注意两点：

1. 接收方不应过分推迟发送确认，否则会导致发送方不必要的重传，这反而浪费了网络的资源。 
2. 捎带确认实际上并不经常发生，因为大多数应用程序很少同时在两个方向上发送数据。

### TCP 的运输连接管理

#### TCP 的连接建立

TCP的连接有三个阶段：

1. 连接建立
2. 数据传送
3. 连接释放

TCP 连接的管理就是使 TCP 连接的建立和释放都能正常地进行。

##### 连接建立

TCP的连接建立也要解决三个问题：

1. 使每一方能够确认对方的存在
2. 允许双方协商一些参数，比如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等
3. 能够对运输的实体资源进行分配

TCP 连接的建立采用客户服务器方式。主动发起连接建立的应用进程叫做客户 (client)。被动等待连接建立的应用进程叫做服务器 (server)。

TCP 建立连接的过程叫做握手。握手需要在客户和服务器之间交换三个 TCP 报文段。称之为**三报文**握手。采用三报文握手主要是为了防止已失效的连接请求报文段突然又传送到了，因而产生错误。

以下是建立TCP连接的图示：

![image-20231117104110054](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20231117104110054.png?x-oss-process=style/blog)

#### TCP 的连接释放

TCP 连接释放过程比较复杂。数据传输结束后，通信的双方都可释放连接。TCP 连接释放过程是**四报文**握手/挥手。

数据传输结束后，通信的双方都可释放连接。现在 A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。A 把连接释放报文段首部的FIN = 1，其序号seq = u，等待 B 的确认。

B 发出确认，确认号 ack = u+1，而这个报文段自己的序号 seq = v。TCP 服务器进程通知高层应用进程。从 A 到 B 这个方向的连接就释放了，TCP 连接处于半关闭状态。B 若发送数据，A 仍要接收。

若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。

 A 收到连接释放报文段后，必须发出确认。  在确认报文段中ACK = 1，确认号 ack = w + 1，自己的序号 seq = u + 1

下图为释放TCP连接的的图示：

![image-20231117104837227](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20231117104837227.png?x-oss-process=style/blog)

TCP还有一个保活计时器的概念用来防止TCP连接出现长时间空闲。

保活计时器 通常设置为2小时 。若服务器过了2小时还没有收到客户的信息，它就发送探测报文段。若发送了10个探测报文段（每一个相隔75秒）还没有响应，就假定客户出了故障，因而就终止该连接。 

#### TCP 的有限状态机

箭头旁边的字，表明引起这种变迁的原因，或表明发生状态变迁后又出现什么动作。

图中有三种不同的箭头。

1. 粗实线箭头表示对客户进程的正常变迁。
2. 粗虚线箭头表示对服务器进程的正常变迁。
3. 细线箭头表示异常变迁。 

![image-20231117110348138](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20231117110348138.png?x-oss-process=style/blog)

（不要求掌握）

### TCP的流量控制

#### 利用滑动窗口实现流量控制

一般说来，我们总是希望数据传输得更快一些。但如果发送方把数据发送得过快，接收方就可能来不及接收，这就会造成数据的丢失。**流量控制 (flow control)** 就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。

利用**滑动窗口机制**可以很方便地在 TCP 连接上实现流量控制。其实就是由接受方将自己还剩余多少缓存发送给发送方，告诉发送方下一次该发送多少窗口。

一般来说，用rewd属性来表示剩余接收窗口的大小。比如接受方返回给发送方的数据中包含rewd=400（字节），告诉发送方还能再发送400个字节大小的数据。当rewd属性为0时，将不允许发送方再继续发送数据。当接受方处理完数据时，将再次发送一次请求重置rewd的值并允许发送方继续发送数据。

##### 死锁

如果接受方向发送方发送了零报文窗口后不久，接收缓存又有了一些储存空间，再次向发送方发送ewnd=400的报文段，但是这个报文段在传送过程中丢失了。那么发送方将一直等待接受方的非零窗口通知，而接受方也会一直等待发送方的数据，此时将出现**互相等待的死锁**。

为了解决这个问题，TCP为每一个连接设置了一个**持续计时器(persistence timer)**。

##### 持续计时器

为了解决这个问题， TCP 为每一个连接设有一个**持续计时器  (persistence timer)** 。

只要 TCP 连接的一方收到对方的零窗口通知，就启动该持续计时器。若持续计时器设置的时间到期，就发送一个**零窗口探测报文段**（仅携带 1 字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。

- 若窗口仍然是零，则收到这个报文段的一方就重新设置持续计时器。
- 若窗口不是零，则死锁的僵局就可以打破了。 

#### TCP 的传输效率

可以用不同的机制来控制 TCP 报文段的发送时机:

- 第一种机制是 TCP 维持一个变量，它等于最大报文段长度 MSS。只要缓存中存放的数据达到 MSS 字节时，就组装成一个 TCP 报文段发送出去。
- 第二种机制是由发送方的应用进程指明要求发送报文段，即 TCP 支持的推送 (push) 操作。
- 第三种机制是发送方的一个计时器期限到了，这时就把当前已有的缓存数据装入报文段（但长度不能超过 MSS）发送出去。

如何控制 TCP 发送报文段的时机仍然是一个较为复杂的问题。

### TCP 的拥塞控制

#### 拥塞控制的一般原理

在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种现象称为**拥塞 (congestion)**。最坏结果将导致**系统崩溃**。

比如双十一，漫展抢票的时候付尾款阶段很难支付成功，因为有太多的人都想要购买，向服务器提交的付款请求超出了服务器信息处理的吞吐量，延迟越来越高，最后系统崩溃。

##### 原因

网络拥塞往往是由许多因素引起的。例如：

- 点缓存的容量太小；
- 链路的容量不足；
- 处理机处理的速率太慢；
- 拥塞本身会进一步加剧拥塞；

最根本的原因是 ∑对资源需求 > 可用资源。

##### 拥塞控制与流量控制的区别

###### 流量控制

抑制发送端发送数据的速率，以使接收端来得及接收；是点对点通信量的控制，是**端到端**的问题；

###### 拥塞控制

防止过多的数据注入到网络中，使网络中的路由器或链路不致过载；是一个**全局性**的过程，涉及到与降低网络传输性能有关的所有因素。

拥塞控制的作用如下图。

![image-20231201091733089](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20231201091733089.png?x-oss-process=style/blog)

##### 原理

- 拥塞控制的前提：网络能够承受现有的网络负荷。
- 实践证明，拥塞控制是很难设计的，因为它是一个动态问题。
- 分组的丢失是网络发生拥塞的**征兆**而不是**原因**。正式因为堵塞才会导致丢包现象。
- 在许多情况下，甚至正是**拥塞控制本身**成为引起网络性能恶化、甚至发生死锁的原因。

##### 解决拥塞的思路

- 增加网络可用资源。但是无法从根源上解决问题，往往只是将瓶颈转移到其他环节。
- 减少用户对资源的需求。

#### TCP 的拥塞控制方法

- TCP 采用**基于窗口的方法**进行拥塞控制。该方法属于闭环控制方法。

- TCP发送方维持一个**拥塞窗口 cwnd (Congestion Window)**。其中拥塞窗口的作用域为整个网络，发送端根据当前网络的情况来设置cwnd；而流量控制窗口rwnd的作用域则仅限于一条TCP通信。

- 发送端利用拥塞窗口根据网络的拥塞情况调整发送的数据量。

- 发送窗口大小不仅取决于接收方窗口，还取决于网络的拥塞状况，所以真正的发送窗口值为：

  **真正的发送窗口值 = Min (接收方窗口值，拥塞窗口值) = Min (cwnd, rwnd)**

##### 控制拥塞窗口的原则

只要网络没有出现拥塞，拥塞窗口就可以再增大一些，以便把更多的分组发送出去，这样就可以提高网络的利用率。但只要网络出现拥塞或有可能出现拥塞，就必须把拥塞窗口减小一些，以减少注入到网络中的分组数，以便缓解网络出现的拥塞。

##### 拥塞发生的判断

当 重传定时器 超时，说明网络**已经**发生了拥塞。

当 收到三个重复的ACK，**预示**网络可能会出现拥塞但还未发生拥塞。

至于为什么是三次ACK，可以参考这篇文章：[(3 封私信 / 2 条消息) 为什么收到三个重复的ACK意味着发生拥塞? - 知乎 (zhihu.com)](https://www.zhihu.com/question/280521822/answer/423570673)。

##### 拥塞控制算法

一共有四种控制算法（ RFC 5681）。

- 慢开始 (slow-start)
- 拥塞避免 (congestion avoidance)
- 快重传 (fast retransmit)
- 快恢复 (fast recovery)

###### 慢开始

慢开始的目的是用来确定网络的负载能力或拥塞程度，思路是由小到大逐渐增大拥塞窗口的数值。

它还有两个变量：**拥塞窗口**和**慢开始门限**。

慢开始在每收到一个对新的报文段的确认后，可以把拥塞窗口增加最多一个 SMSS 的数值，以此来控制cwnd拥塞窗口。也就是拥塞窗口 cwnd 每次的增加量 = min (N, SMSS)。其中 N 是原先未被确认的、但现在被刚收到的确认报文段所确认的字节数。

不难看出，当 N < SMSS 时，拥塞窗口每次的增加量要小于 SMSS。用这样的方法逐步增大发送方的拥塞窗口 cwnd，可以使分组注入到网络的速率更加合理。

![image-20231201095803574](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20231201095803574.png?x-oss-process=style/blog)

使用慢开始算法后，每经过一个**传输轮次 (transmission round)**，拥塞窗口 cwnd 就加倍。 一个传输轮次所经历的时间其实就是往返时间 RTT。

“传输轮次”更加强调：把拥塞窗口 cwnd 所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。例如，拥塞窗口 cwnd = 4，这时的往返时间 RTT 就是发送方连续发送 4 个报文段，并收到这 4 个报文段的确认，总共经历的时间。

关于慢开始门限状态变量ssthresh，用法如下：

1. 当 cwnd < ssthresh 时，使用慢开始算法。
2. 当 cwnd > ssthresh 时，停止使用慢开始算法而改用**拥塞避免算法**。
3. 当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用**拥塞避免算法**。

###### 拥塞避免

拥塞避免算法即让拥塞窗口 cwnd 缓慢地增大，避免出现拥塞。每经过一个传输轮次，拥塞窗口 cwnd = cwnd + 1。使拥塞窗口 cwnd 按线性规律缓慢增长。在拥塞避免阶段，具有 “加法增大” (Additive Increase) 的特点。

无论在慢开始阶段还是在拥塞避免阶段，一旦发送方判断网络出现拥塞（重传定时器超时），就执行以下步骤：

1. ssthresh = max (cwnd/2，2)
2. cwnd = 1
3. 执行慢开始算法

这样可以迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。 

![image-20231201100745473](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20231201100745473.png?x-oss-process=style/blog)

“拥塞避免”并非指完全能够避免了拥塞。利用以上的措施要完全避免网络拥塞还是不可能的。“拥塞避免”是说在拥塞避免阶段把拥塞窗口控制为按线性规律增长，**使网络比较不容易出现拥塞**。 

回到上图，当拥塞窗口 cwnd = 16 时（图中的点），出现了一个新的情况，就是发送方一连收到 3 个对同一个报文段的重复确认（图中记为 3-ACK）。发送方改为执行**快重传**和**快恢复算法**。（划考点）

###### 快重传算法

**发送方只要一连收到三个重复确认**，就知道接收方确实没有收到报文段，因而应当**立即进行重传（即“快重传”）**，这样就不会出现超时，发送方也不就会误认为出现了网络拥塞。使用快重传可以使整个网络的吞吐量提高约20%。不难看出，快重传并非取消重传计时器，而是在某些情况下可以更早地（更快地）重传丢失的报文段。 

采用**快重传 FR (Fast Retransmission) 算法**可以让发送方**尽早知道发生了个别报文段的丢失**。快重传 算法首先要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认，即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认。

###### 快恢复算法

当发送端收到连续三个重复的确认时，由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，而是执行快恢复算法 FR (Fast Recovery) 算法：

1. 慢开始门限 ssthresh = 当前拥塞窗口 cwnd / 2 ；
2. 新拥塞窗口 cwnd = 慢开始门限 ssthresh ；
3. 开始执行拥塞避免算法，使拥塞窗口缓慢地线性增大。

可以看出，在拥塞避免阶段，拥塞窗口是按照线性规律增大的。这常称为“**加法增大**” AI (Additive Increase)。当出现超时或3个重复的确认时，就要把门限值设置为当前拥塞窗口值的一半，并大大减小拥塞窗口的数值。这常称为“**乘法减小**”MD (Multiplicative Decrease)。二者合在一起就是所谓的 **AIMD 算法**。

![image-20231201103442602](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20231201103442602.png?x-oss-process=style/blog)

##### 发送窗口的上限值

发送方的发送窗口的上限值应当取为接收方窗口 rwnd 和拥塞窗口 cwnd 这两个变量中较小的一个，即应按以下公式确定：

**发送窗口的上限值 = Min [rwnd, cwnd]**

- 当 rwnd < cwnd 时，是接收方的接收能力限制发送窗口的最大值。
- 当 cwnd < rwnd 时，则是网络的拥塞限制发送窗口的最大值。

也就是说，rwnd 和 cwnd 中数值较小的一个，控制了发送方发送数据的速率。

## 应用层

（6.1,6.4,6.5,6.6）

### DNS域名系统

许多应用层软件经常直接使用**域名系统**DNS（Domain Name System），但计算机用户只是间接而不是直接使用DNS。用户只负责记忆域名，而计算机则将其转换成对应的IP地址。

#### 互联网的域名结构

互联网采用层次树状结构的命名方法。不同层级的域名用点隔开，格式如下：

…….四级域名.三级域名.二级域名.顶级域名，比如www.baidu.com。

需要指出的是域名只是一个逻辑概念，它使用有助于记忆的字符串来方便人来使用，而计算机则使用定长的32位IP地址。域名的点和IP地址中的点没有任何关系。

顶级域名举例如下：

- .com
- .cn
- .net
- .edu
- ……

#### 域名服务器

每一片区域设置一个权限域名服务器来管辖这片地区的计算机，它储存着当前所有域名对应到IP地址的投射。

在权限域名服务器上还有顶级域名服务器，最高级的是根域名服务器，用来管理全世界的域名服务。

域名服务器有以下四种类型：

- 根域名服务器
- 顶级域名服务器
- 权限域名服务器
- 本地域名服务器

##### 根域名服务器

是**最高层次**的域名服务器，也是**最重要**的域名服务器。

只要本地服务器无法解析域名，首先就求助根服务器。根服务器一共有13套**装置**，而不是13套**机器**，分别对应前13个字母（a-m）。全世界在各地都安装了根域名服务器，这样世界上大部分DNS域名服务器都能就近找到一个根域名服务器。

### 万维网

#### 概述

万维网WWW（World Wide Web），并不是某种特殊的计算机网络，它是一个很大规模的、联机式的信息储藏所。万维网用链接的方法能非常方便的从互联网上的一个站点访问另一个站点，从而主动地按需获取丰富的信息。

这种访问方式被称为“**链接**”。

##### 超媒体与超文本

万维网是**分布式超媒体（hypermedia）**系统，它是**超文本（hypertext）**系统（即http）的拓展。

一个超文本由多个信息源链接构成，利用一个链接可以使用户找到另一个文档。超文本是万维网的基础。所谓超文本就是在文本的基础上加入了链接。

超媒体和超文本的区别是文档内容不同。超文本文档仅包含文本信息，而超媒体文档还包含其他表示方式的信息，如图形、图像、声音、动画，甚至包括活动视频图像。

##### 万维网的工作方式

万维网以**客户-服务器**方式工作。

浏览器就是在用户计算机上运行的万维网客户端程序，万维网文档所驻留的计算机则运行服务器程序，因此这些计算机也称为**万维网服务器**。当客户程序浏览器像服务器程序发出请求时，服务器程序就向客户程序返回客户要的万维网文档。在一个客户程序上显示出的万维网文档被称为**页面（page）**。

(1) 怎样标志分布在整个互联网上的万维网文档？ 

- 使用统一资源定位符 **URL (Uniform Resource Locator)** 来标志万维网上的各种文档。
- 使每一个文档在整个互联网的范围内具有唯一的标识符 URL。 

(2) 用何协议实现万维网上各种超链的链接？ 

- 在万维网客户程序与万维网服务器程序之间进行交互所使用的协议，是**超文本传送协议 HTTP (HyperText Transfer Protocol)**。
- HTTP 是一个应用层协议，它使用 TCP 连接进行可靠的传送。

(3) 怎样使各种万维网文档都能在互联网上的各种计算机上显示出来，同时使用户清楚地知道在什么地方存在着超链？ 

- **超文本标记语言 HTML (HyperText Markup Language)** 使得万维网页面的设计者可以很方便地用一个超链从本页面的某处链接到互联网上的任何一个万维网页面，并且能够在自己的计算机屏幕上将这些页面显示出来。 

(4) 怎样使用户能够很方便地找到所需的信息？

 为了在万维网上方便地查找信息，用户可使用各种的**搜索工具**（即搜索引擎）。 

#### 统一资源定位符URL

资源定位符 URL 是对可以从互联网上得到的资源的位置和访问方法的一种简洁表示。

URL 给资源的位置提供一种抽象的识别方法，并用这种方法给**资源定位**。

只要能够对资源定位，系统就可以对资源进行各种操作，如存取、更新、替换和查找其属性。URL 相当于一个文件名在网络范围的扩展。**因此 URL 是与互联网相连的机器上的任何可访问对象的一个指针**。 

##### 一般形式

由以冒号隔开的两大部分组成，并且在 URL 中的字符对大写或小写没有要求。

URL 的一般形式是：<协议>://<主机>:<端口>/<路径>

![image-20231208085335944](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20231208085335944.png?x-oss-process=style/blog)

协议一般是以上三种。有时候也可以省略，浏览器会帮助用户自动补全。

主机是存放资源的主机在互联网中的域名。

HTTP的**默认端口号是80**，路径就是到互联网上某个主页更复杂的一些从属结构的页面。端口和路径有时候可以省略，浏览器会自动帮你补全。

#### 超文本传输协议

为了使超文本的链接能够高效率地完成，需要用 HTTP 协议来传送一切必须的信息。

从层次的角度看，HTTP 是**面向事务的 (transaction-oriented)** 应用层协议，它是万维网上能够可靠地交换文件（包括文本、声音、图像等各种多媒体文件）的重要基础。 

#### 工作过程

客户端和服务器首先建立TCP连接，然后客户端发送HTTP请求报文，服务器返回HTTP响应报文，最后释放TCP连接。这就是一次完整的万维网工作过程。

每个万维网网点都有一个服务器进程，它不断地**监听 TCP 的端口 80**，以便发现是否有浏览器向它发出连接建立请求。一旦监听到连接建立请求并建立了 TCP 连接之后，浏览器就向万维网服务器发出浏览某个页面的请求，服务器接着就返回所请求的页面作为响应。最后，TCP 连接就被释放了。

在浏览器和服务器之间的请求和响应的交互，必须按照规定的格式和遵循一定的规则。这些格式和规则就是**超文本传送协议 HTTP**。HTTP 规定在 HTTP 客户与 HTTP 服务器之间的每次交互，都由一个 ASCII 码串（即人类可阅读的字符串）构成的请求和一个类似的通用互联网扩充，即“类 MIME (MIME-like)”的响应组成。**HTTP 报文通常都使用 TCP 连接传送**，故wireshark中TCP流尤为重要。

#### 特点

- HTTP使用了**面向连接的TCP**作为运输层协议，保证了数据的可靠性。
- HTTP协议本身也是**无连接的**，虽然它使用了面向连接的TCP提供的服务。
- HTTP是**面向事务**的客户服务器协议。
- HTTP 1.0 协议是无状态的。

无状态是指客户端和服务器完成交互后双方就断开连接，因此无法进行进一步互动。这是一个非常老的协议，现在一般使用HTTP**持续连接**。

#### 持续链接

指万维网服务器在发送响应后仍然可以在一段时间内保持这条连接，使同一个客户（浏览器）和该服务器可以继续在这条连接上传送后续的请求报文和响应报文。这并不局限于传送同一个页面上链接的文档，而是只要这些文档都在同一个服务器上就行。

目前一些流行的浏览器（例如，IE 6.0）的默认设置就是使用 HTTP/1.1。

#### 代理服务器

**代理服务器** (proxy server) 又称为**万维网高速缓存** (Web cache)，它代表浏览器发出 HTTP 请求。万维网高速缓存把最近的一些请求和响应暂存在本地磁盘中。当与暂时存放的请求相同的新请求到达时，万维网高速缓存就把暂存的响应发送出去，而不需要按 URL 的地址再去互联网访问该资源。

#### HTTP的报文结构

HTTP 有两类报文：

- 请求报文——从客户向服务器发送请求报文。
- 响应报文——从服务器到客户的回答。
- 由于 HTTP 是面向正文的 (text-oriented)，因此在报文中的每一个字段都是一些 ASCII 码串，因而每个字段的长度都是不确定的。

##### 请求报文结构

报文由三个部分组成：开始行、首部行和实用主体。

在请求报文中，开始行就是请求行。实用主体通常不用。

![image-20231208093532859](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20231208093532859.png?x-oss-process=style/blog)

“方法”是面向对象技术中使用的专属名词。所谓“方法”就是对所请求的对象进行的操作，因此这些方法实际上也就是一些命令。因此，请求报文的类型是由它所采用的方法决定的。 在Web中经常用到。

![image-20231208093655477](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20231208093655477.png?x-oss-process=style/blog)

“URL”是请求资源的URL。

版本是HTTP的版本。

响应报文的开始行是状态行。状态行包括三项内容，即 HTTP 的版本，状态码，以及解释状态码的简单短语。

###### 状态码

状态码都是三位数字。

- 1xx 表示通知信息的，如请求收到了或正在进行处理。
- 2xx 表示成功，如接受或知道了。
- 3xx 表示重定向，表示要完成请求还必须采取进一步的行动。
- 4xx 表示客户的差错，如请求中有错误的语法或不能完成。
- 5xx 表示服务器的差错，如服务器失效无法完成请求。

#### Cookie

万维网站点可以使用 Cookie 来跟踪用户。

Cookie 表示在 HTTP 服务器和客户之间传递的状态信息。使用 Cookie 的网站服务器为用户产生一个唯一的识别码。利用此识别码，网站就能够跟踪该用户在该网站的活动。 

### 万维网的文档

#### 超文本标记语言 HTML

##### HTML

超文本标记语言 HTML 中的 Markup 的意思就是“设置标记”。HTML是一门标记语言。HTML 定义了许多用于排版的命令（即标签）。HTML 把各种标签嵌入到万维网的页面中。这样就构成了所谓的 HTML 文档。HTML 文档是一种可以用任何文本编辑器创建的 ASCII 码文件。 

仅当 HTML 文档是以 .html 或 .htm 为后缀时，浏览器才对此文档的各种标签进行解释。如 HTML 文档改换以 .txt 为其后缀，则 HTML 解释程序就不对标签进行解释，而浏览器只能看见原来的文本文件。当浏览器从服务器读取 HTML 文档后，就按照 HTML 文档中的各种标签，根据浏览器所使用的显示器的尺寸和分辨率大小，重新进行排版并恢复出所读取的页面。

HTML还规定了链接的设置方法。每个链接都有一个起点和终点。远程链接：超链的终点是其他网点上的页面。本地链接：超链指向本计算机中的某个文件。

##### XML

XML (Extensible Markup Language) 是可扩展标记语言，它和 HTML 很相似。但 XML 的设计宗旨是传输数据，而不是显示数据（HTML 是为了在浏览器上显示数据）。XML 不是要替换 HTML，而是对 HTML 的补充。

##### XHTML

XHTML (Extensible HTML) 是可扩展超文本标记语言，它与 HTML 4.01 几乎是相同的。但 XHTML 是更严格的 HTML 版本，也是一个 W3C 标准（2000年1月），是作为一种 XML 应用被重新定义的 HTML，并将逐渐取代 HTML。新的浏览器都支持 XHTML。

##### CSS

CSS (Cascading Style Sheets) 是层叠样式表，它是一种样式表语言，用于为 HTML 文档定义布局。CSS 与 HTML 的区别就是：HTML 用于结构化内容，而 CSS 则用于格式化结构化的内容。

#### 动态万维网文档

静态文档是指该文档创作完毕后就存放在万维网服务器中，在被用户浏览的过程中，内容不会改变。

 动态文档是指文档的内容是在浏览器访问万维网服务器时才由应用程序动态创建。

动态文档和静态文档之间的主要差别体现在服务器一端。这主要是文档内容的生成方法不同。而从浏览器的角度看，这两种文档并没有区别。 

为了处理动态文档，应该增加另一个程序，用来处理浏览器发来的数据，并创建动态文档。并且增加一个机制，用来使万维网服务器把浏览器发来的数据传送给这个应用程序，然后万维网服务器能够解释这个应用程序的输出，并向浏览器返回HTML文档。

#### 活动万维网文档

活动文档 (active document) 技术把所有的工作都转移给浏览器端。每当浏览器请求一个活动文档时，服务器就返回一段程序副本在浏览器端运行。活动文档程序可与用户直接交互，并可连续地改变屏幕的显示。由于活动文档技术不需要服务器的连续更新传送，对网络带宽的要求也不会太高。 （比如一些基于JavaScript的小游戏，比如java）。

### 电子邮件

![image-20231208100534549](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20231208100534549.png?x-oss-process=style/blog)

每一个协议都是基于TCP的连接。

#### 用户代理UA/User Agent

是用户和电子邮件系统的端口，又被称为电子邮件客户端软件。

基本功能：撰写、显示、处理和通信。

#### 邮件服务器/Mail Server

又被称为邮件传输代理。

功能：发送和接收邮件，同时还要向发信人报告邮件传输情况。

按照客户-服务器方式工作，在发送时使用两个不同的协议：SMTP、POP3。

邮件服务器必须能够同时充当客户和服务器。

#### 邮件发送和读取协议

邮件的发送和读取使用不同的协议。

简单邮件发送协议SMTP：用于在用户代理向邮件服务器或邮件服务器之间发送邮件。

邮局协议 POP3：用于用户代理从邮件服务器读取邮件。

SMTP和POP3（或IMAP）都是使用TCP连接来传送邮件的，目的是为了可靠地传送邮件。

#### 基于万维网的电子邮件

用户代理必须在计算机中安装代理软件，但可能不能安装或者不允许安装，所以，不方便收发邮件。因此我们使用万维网来发送邮件。

万维网电子邮件不需要在计算机中再安装用户代理软件。只要计算机能联网，就能非常方便的收发邮件，且界面更加友好。

万维网电子邮件在发送和接收电子邮件时使用HTTP协议，两个邮件服务器之间传送邮件时使用了STMP。

![image-20231208105144320](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20231208105144320.png?x-oss-process=style/blog)

#### 通用互联网邮件扩充MIME

STMP有以下缺点：

- SMTP 不能传送可执行文件或其他的二进制对象。
- SMTP 限于传送 7 位的 ASCII 码。许多其他非英语国家的文字（如中文、俄文，甚至带重音符号的法文或德文）就无法传送。
- SMTP 服务器会拒绝超过一定长度的邮件。
- 某些 SMTP 的实现并没有完全按照 SMTP 标准。 

通用互联网邮件扩充MIME并没有改动STMP或者取代它，MIME的意图是继续使用目前的格式，但增加了主体的结构，并且定义了传送非ASCII码的编码规则。

### 动态主机配置协议DHCP

在协议软件中，给协议参数赋值的动作叫做协议配置。一个协议软件在使用之前必须是已正确配置的。连接到互联网的计算机的协议软件需要配置的参数包括：

1. IP地址
2. 子网掩码
3. 默认路由器的IP地址
4. 域名服务器的IP地址

互联网广泛使用的动态主机配置协议 **DHCP (Dynamic Host Configuration Protocol)** 提供了即插**即用连网 (plug-and-play networking)** 的机制。这种机制允许一台计算机加入新的网络和获取 IP 地址，而不用手工配置。DHCP给运行服务器软件、且位置固定的计算机指派一个永久地址，给运行客户端软件的计算机分配一个临时地址。

例如，需要 IP 地址的主机在启动时就向 DHCP 服务器广播发送发现报文（DHCPDISCOVER），这时该主机就成为 DHCP 客户。本地网络上所有主机都能收到此广播报文，但只有 DHCP 服务器才回答此广播报文。DHCP 服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的 IP 地址池 (address pool) 中取一个地址分配给该计算机。DHCP服务器的回答报文叫做提供报文（DHCPOFFER）。 

### 文件传送协议

文件传送协议FTP（File Transfer Protocol）是互联网上使用的最广泛的文件协议。它提供交互式的访问，允许客户指明文件的类型和格式，并且允许文件具有存取权限。FTP屏蔽了各个计算机系统的细节，所以适合于在异构网络中任意计算机之间传送文件。

----

（待更新的分割线...）

![301790](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/301790.jpg?x-oss-process=style/blog)
