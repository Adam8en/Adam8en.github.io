---
title: 计算机组成指北（四）
date: 2024-09-27 11:42:55
updated: 2024-09-27 11:42:55
tags: 
  - 计算机组成原理
  - 指令系统
categories: 计算机组成指北
cover: https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/B457C9EC79F0421BB773651E8FFE5F05.jpg
description: 计算机组成指北的第四部分！介绍了计算机的指令系统，难度不大，如果有汇编基础将会很容易理解。
---

## 第七章 指令系统

> 难度相对不大
>
> 扩展操作码技术
> 寻址方式包括指令的寻址和操作数的寻址，了解概念
> 指令集 risc和cisc的区别表

至此，我们算是介绍完了计算机底层的硬件部分，最基础的M0层学习完毕:champagne::champagne::champagne:！

![Cache_577189bb64f13db1](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/Cache_577189bb64f13db1.jpg)

呃等等，后面还有更难的M1层还没开始学呢……褒姒了。（还记得记得M0和M1吗？如果记不得就去复习下前面的计算机层次结构）

![Cache_6818278e85975c59](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/Cache_6818278e85975c59.jpg)

不管怎么说，从这章开始，我们正式开始介绍计算机的指令系统，了解计算机是如何通过微指令的方式与硬件系统交互实现相应的功能。

### 机器指令

一般来说，指令的格式如下图所示：

![image-20240618212628477](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20240618212628477.png)

顾名思义，操作码就是指示计算机应该做出什么样的控制行为，地址码则代表执行操作的内存地址（前提是该操作涉及到了与数据的交互）。

#### 操作码

指令中的操作码反映了机器该做出什么样的操作。操作码的长度可以是固定的，也可以是可变的。前者比如RISC、IBM370等指令字较长时使用，后者则在字长较短的微型计算机被广泛采用，如Intel8086等。一般来说，可变长度的操作码会使控制器的设计变得复杂，所以我们采用**扩展操作码技术**对操作码进行扩充，从而减少指令字长。所谓扩展操作码技术，即通过减少地址码字段的长度来扩充操作码，从而保持指令字段整体长度不变。

以下是一种扩展操作码的安排示意图：

<img src="https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20240619152949278.png" alt="image-20240619152949278" style="zoom:50%;" />

我们可以很容积总结出扩展操作码的规律：十六位指令码分为四组，每一个小组由2^4^种组合，除零地址指令外，需要抽出1111来标识进入下一组，故每种地址指令（除零地址指令外）均有2^4^-1=15条。

如果需要进一步扩展操作码，可以通过减少地址指令条数来实现。比如三地址指令操作码，每减少一种可多构成2^4^ 种二地址指令；二地址指令操作码，每减少一种可多构成2^4^ 种一地址指令。这是因为每减少一条高地址指令，就会增加低地址指令额外的组成种类。

> 例题：设指令字长16位，操作数地址码6位，指令有零地址、一地址、二地址3种。
>
> （1）若操作码长度固定，零地址指令P种，一地址指令Q种，则二地址指令最多几种？
>
> 地址码6位，支持二地址指令，则操作码位数为
>
> $16−6−6=4$
>
> 则总共有2^4^=16种指令，由于操作码长度固定，则二地址指令最多：
>
> $16−P−Q$
>
> （2）采用扩展操作码技术，若二地址指令X种，零地址指令Y种，则一地址指令最多几种？
>
> 二地址指令每减少一种，可构成2^6^种一地址指令，一地址指令每减少一种，可构成2^6^种零地址，二地址指令X种，则一地址指令最多：
>
> $(2^4−X)×2^6$种
>
> 设一地址指令M种，则零地址指令最多$((2^4−X)×2^6 −M)×2^6$种，因零地址指令Y种，解方程：
>
> $((2^4−X)×2^6 −M)×2^6=Y$
>
> 可得一地址指令最多：
>
> $M=(2^4−X)×2^6−Y×2^{-6}$

#### 地址码

地址码用来指出该指令的源操作数的地址（一个或两个）、结果的地址以及下一条指令的地址，又分四地址操作码、三地址操作码、二地址操作码以及一地址操作码。

假设指令字长为32位，其中操作码固定8位，则有：

- 四地址

  寻址范围：2^6^=64

  ![image-20240619155842877](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20240619155842877.png)

- 三地址

  寻址范围：2^8^=256

  ![image-20240619160231545](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20240619160231545.png)

- 二地址

  寻址范围：2^12^=4K

  ![image-20240619160327394](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20240619160327394.png)

- 一地址

  寻址范围：2^24^=16M

  ![image-20240619160340900](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20240619160340900.png)

- 零地址

  零地址指令在指令字中无地址码，要么是不需要操作数的指令（空操作NOP、HLT停机等），要么是其操作数地址隐藏在堆栈中（子程序返回RET、中断返回IRET等）

#### 指令字长

早期的计算机指令字长一般是固定的，所以只需要取出固定的字长就可以执行指令。但是现在的计算机，指令字长一般是可变的。为了提高运行速度和节省存储空间，一般把指令设计为按字节的倍数变化。

### 寻址方式

寻址方式，即确定本条指令的操作数地址及下一条欲执行指令的指令地址。分为指令寻址和数据寻址。了解概念即可。

#### 指令寻址

指令寻址的方式比较简单，即由程序计数器PC（Program Counter）按顺序指向下一条指令即可。如果遇到跳跃指令，则由跳跃指令指出下一条指令的地址。

<img src="https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20240619161533737.png" alt="image-20240619161533737" style="zoom:50%;" />

#### 数据寻址

一般来说，数据寻址的格式如下图所示：

<img src="https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20240619162256574.png" alt="image-20240619162256574" style="zoom:50%;" />

操作码代表对数据执行操作的类型；寻址特征代表执行什么样的寻址；形式地址A则储存数据的相关信息，它可能就是数据本身，也可能是数据所在的真实地址，也可能是数据所在地址的地址。一般来说，指令地址码中的字段通常不代表操作数的真实地址。

方便起见，我们约定指令字长=存储字长=机器字长；形式地址记为A，真实地址/有效地址记为EA。

> 1. **指令字长**：指令字长是指CPU一次能够处理的指令的位数。在某些体系结构中，所有的指令都是固定长度的，例如16位、32位或64位。
> 2. **存储字长**：存储字长是指存储器中每个存储单元能够存储的数据的位数。这通常与指令字长相同，意味着存储器中的每个单元可以存储相同数量的位。
> 3. **机器字长**：机器字长是指CPU在执行算术和逻辑操作时能够一次性处理的数据位数。这通常与指令字长和存储字长相同，这样设计可以简化计算机的内部逻辑和提高效率。

数据寻址方式相对复杂，共有十种数据寻址方式，现一一介绍如下：

##### 立即寻址

立即寻址时，此时形式地址A就是操作数，即输入立即数。

特点：

- 指令执行阶段不访存
- 立即数是采用补码存放的，所以可正可负
- A的位数限制了输入立即数的范围

##### 直接寻址

直接寻址时，有效地址由形式地址直接给出，EA=A。

特点：

- 执行阶段访问一次寄存器
- A的位数决定了该指令操作数的寻址范围
- 操作数的地址不易修改，此时必须要修改A

##### 隐含寻址

隐含寻址时，操作数地址隐含在操作码中。

比如8086的MUL指令，被乘数隐含在 AX（16位）或 AL（8位）中；MOVS 指令，源操作数的地址隐含在 SI 中，目的操作数的地址隐含在 DI 中。

特点：

-   指令字中少了一个地址字段，可缩短指令字长

##### 间接寻址

间接寻址时，有效地址由形式地址间接提供，即形式地址指向真实地址的地址，类似指针的概念。间接寻址的次数视具体情况而定。EA=(A)。

特点：

- 执行指令阶段会进行2次或多次访存
- 可以扩大寻址范围
- 便于编制程序，指针的运用十分方便

##### 寄存器寻址

寄存器寻址时，有效地址即为寄存器编号，数据储存在寄存器中，EA=R~i~。

特点：

- 执行阶段不访存，只访问寄存器，执行速度快
- 寄存器个数有限，故指令字较短，可以缩短指令字长

##### 寄存器间接寻址

寄存器间接寻址时，有效地址在寄存器编号中，EA=(R~i~)。

特点：

- 有效地址在寄存器中，操作数在存储器中，执行阶段访存。它比间接寻址少访存一次。
- 一般用于编制循环程序

##### 基址寻址

基址寻址又分为两种：隐式基址寻址和显示基址寻址。

###### 隐式基址寻址

即采用专用寄存器作基址寄存器，此时EA=(BR)+A，BR为基址寄存器。

例如8086CPU中，默认DS为段地址寄存器，DI为段偏移地址寄存器。在访问数据时，真实的内存地址表现为：DS\*16+DI，扩大了数据表示范围。

特点：

- 可扩大寻址范围
- 有利于多道程序
- BR的内容由操作系统或者管理程序确定
- 在程序执行过程中BR内容不变，形式地址可变

###### 显示基址寻址

即采用通用寄存器作基址寄存器，此时EA=(R~0~)+A，R~0~为用户自己指定的通用寄存器。

特点：

-  由用户指定哪个通用寄存器作为基址寄存器
-  基址寄存器的内容由操作系统确定
-  在程序的执行过程中 R0  内容不变，形式地址 A 可变

##### 变址寻址

变址寻址与基址寻址极为相似，其有效地址EA等于指令字中的形式地址A与变址寄存器的内容相加之和，即EA=A+(IX)。

由于两者的应用场合不同，所以我们主要通过应用场景来区分变址寻址和基址寻址。基址寻址主要用于为程序或数据分配存储空间，由操作系统或管理程序决定，故程序执行过程中其值不可变；而变址寻址的内容是由用户设定的，在执行过程中内容可变，而指令字的A不可变，主要用来处理**数组问题**。

比如在数组处理过程中，设定A为数组的首地址，然后通过改变变址寄存器的值来访问数组的各个元素，特别适合编制循环程序。

特点如下：

- 可以扩大寻址范围
- IX的内容由用户给定
- 在程序的执行过程中 IX 内容可变，形式地址 A 不变
- 便于处理数组问题

##### 相对寻址

相对寻址的有效地址是将程序计数器PC的内容（即当前指令地址）与指令字中的形式地址相加而成，即EA=(PC)+A。A 是相对于当前指令的位移量（可正可负，补码）

特点：

- A的位数决定操作数的寻址范围
- 对于编写浮动程序特别有利，无论程序在主存的哪段区域都能正常运行
- 广泛应用于转移指令

##### 堆栈寻址

堆栈可以分为硬堆栈和软堆栈两种，前者由多个寄存器实现，后者由指定的存储空间实现。堆栈的运行方式可以分为先进后出和先进先出两种。先进后出型堆栈的操作数只能从一个出入口进行读写，栈顶地址由寄存器SP指出。因此堆栈寻址本质上也可以视为寄存器间接寻址。

整理表格如下：

| 寻址方式       | 说明                                                         | 特点                                                         |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 立即寻址       | 此时形式地址A就是操作数，即输入立即数。                      | - 指令执行阶段不访存<br> - 立即数是采用补码存放的，所以可正可负<br> - A的位数限制了输入立即数的范围 |
| 直接寻址       | 有效地址由形式地址直接给出，EA=A。                           | - 执行阶段访问一次寄存器<br> - A的位数决定了该指令操作数的寻址范围<br> - 操作数的地址不易修改，此时必须要修改A |
| 隐含寻址       | 操作数地址隐含在操作码中。                                   | - 指令字中少了一个地址字段，可缩短指令字长                   |
| 间接寻址       | 有效地址由形式地址间接提供，即形式地址指向真实地址的地址，类似指针的概念。 | - 执行指令阶段会进行2次或多次访存<br> - 可以扩大寻址范围<br> - 便于编制程序，指针的运用十分方便 |
| 寄存器寻址     | 有效地址即为寄存器编号，数据储存在寄存器中，EA=R~i~。        | - 执行阶段不访存，只访问寄存器，执行速度快<br> - 寄存器个数有限，故指令字较短，可以缩短指令字长 |
| 寄存器间接寻址 | 有效地址在寄存器编号中，EA=(R~i~)。                          | - 有效地址在寄存器中，操作数在存储器中，执行阶段访存。它比间接寻址少访存一次。<br> - 一般用于编制循环程序 |
| 基址寻址       | 基址寻址分为隐式基址寻址和显示基址寻址。                     |                                                              |
| 隐式基址寻址   | 采用专用寄存器作基址寄存器，此时EA=(BR)+A，BR为基址寄存器。  | - 可扩大寻址范围<br> - 有利于多道程序<br> - BR的内容由操作系统或者管理程序确定<br> - 在程序执行过程中BR内容不变，形式地址可变 |
| 显示基址寻址   | 采用通用寄存器作基址寄存器，此时EA=(R~0~)+A，R~0~为用户自己指定的通用寄存器。 | - 由用户指定哪个通用寄存器作为基址寄存器<br> - 基址寄存器的内容由操作系统确定<br> - 在程序的执行过程中 R0 内容不变，形式地址 A 可变 |
| 变址寻址       | 有效地址EA等于指令字中的形式地址A与变址寄存器的内容相加之和，即EA=A+(IX)。 | - 可以扩大寻址范围<br> - IX的内容由用户给定<br> - 在程序的执行过程中 IX 内容可变，形式地址 A 不变<br> - 便于处理数组问题 |
| 相对寻址       | 有效地址是将程序计数器PC的内容（即当前指令地址）与指令字中的形式地址相加而成，即EA=(PC)+A。 | - A的位数决定操作数的寻址范围<br> - 对于编写浮动程序特别有利，无论程序在主存的哪段区域都能正常运行<br> - 广泛应用于转移指令 |
| 堆栈寻址       | 堆栈可以分为硬堆栈和软堆栈两种，前者由多个寄存器实现，后者由指定的存储空间实现。 | - 堆栈的运行方式可以分为先进后出和先进先出两种。<br> - 堆栈寻址本质上也可以视为寄存器间接寻址。 |

### 指令集

主要了解两种指令集：

- RISC（Reduced Instruction Set Computer）精简指令集计算机
- CISC（Complex Instruction Set Computer）复杂指令集计算机

下面的比较图需要牢固记忆：

|            | RISC                         | CISC                         |
| ---------- | ---------------------------- | ---------------------------- |
| CPU        | 体积小、能耗低、性能功耗比高 | 体积大、能耗高、性能功耗比低 |
| 计算效率   | 低                           | 高                           |
| 软件       | 体积大、指令复杂度高         | 体积小、指令复杂度低         |
| 代表性产品 | ARM                          | x86                          |

现在CISC与RISC正在逐步走向融合。

……

……

第四章到此结束！敬请阅读第五部分:thumbsup:

---

![B457C9EC79F0421BB773651E8FFE5F05](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/B457C9EC79F0421BB773651E8FFE5F05.jpg)
