---
title: 计算机组成指北（七）
date: 2024-09-27 11:43:26
updated: 2024-09-27 11:43:26
tags: 
  - 计算机组成原理
  - 控制单元设计
  - 微指令编码方式
categories: 计算机组成指北
cover: https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/C10AD1752A521C3C297E7D81400952F1.jpg
description: 计算机组成指北的第七部分&完结篇！介绍了控制单元的设计原理与微指令编码方式，一般作为压轴题考察。
---

## 第十章 控制单元的设计

> 就是一道大题
> 最关键的微程序设计指令
> 画出微指令码点

学习完控制单元的结构后，我们来学习控制单元的两种设计方法：

- 组合逻辑设计
- 微程序设计

这也是计算机组成原理的最后一个组成部分。

### 组合逻辑设计

#### CU外特性

要理解组合逻辑设计的方式，我们先给出CU的外特性图并且一一说明。

<img src="https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20240706141431460.png" alt="image-20240706141431460" style="zoom:50%;" />

其中，CU发出的**控制信号的先后关系与时间点的确定**，由节拍发生器确定。如果你忘记了节拍的概念，去复习第九章的多级时序系统，或者参考下图。

<img src="https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20240706141948426.png" alt="image-20240706141948426" style="zoom:33%;" />

而CU**产生什么控制命令**，依赖于：

1. 操作码译码输出，一条指令，对应仅有一条线有效。也就是图中的操作码译码部分，n位操作码对应2^n^条指令，所有译码器输出2^n^根线到CU。
2. 标志，如跳转条件等也可以控制CU输出什么样的微指令

在一个节拍内，C~0~到C~k~会有一个或几个有效，即产生的微指令。

#### 微操作的节拍安排

回顾了CU外特性后，我们来讨论各种微操作如何进行安排。

假设我们采取同步控制的方式，且认为一个机器周期内含3个节拍，CPU的内部采取非总线方式设计。微操作按照执行的顺序安排在给定的节拍中，控制计算机的各个组成部分稳定协调的工作。一个时钟周期有多少个节拍，跟周期中需要产生控制信号的数量，复杂程度，控制信号之间是否能并行都有关

在安排微操作时序时，我们要遵循三个原则：

1. 微操作的**先后顺序**不得随意更改
2. **被控对象不同**的微操作尽量安排在一个节拍内完成，即**可以并行**的微操作，没有先后顺序的操作
3. **占用时间较短**的微操作尽量安排在一个节拍内完成，并**允许有先后顺序**，比如一个在上升沿，一个在下降沿

基于以上三大原则，我们来重新回顾取指周期、间址周期、执行周期、中断周期的节拍安排。

##### 取值周期微操作的节拍安排

1. T~0~

   $PC\rightarrow MAR$

   $1\rightarrow R$

   基于原则二，取指地址送入MAR和控制寄存器发出读信号可以并行。

2. T~1~

   $M(MAR)\rightarrow MDR$

   $(PC)+1\rightarrow PC$

   基于原则二，将数据从内存取回和递增PC可以并行

3. T~2~

   $MDR\rightarrow IR$

   $OP(IR)\rightarrow ID$

   基于原则三，由于MDR将指令送入IR是在CPU内部传输，故耗时短，和指令译码安排在同一节拍

##### 间址周期微操作的节拍安排

1. T0

   $Ad(IR)\rightarrow MAR$

   $1\rightarrow R$

2. T2

   $M(MAR)\rightarrow MDR$

3. T3

   $MDR\rightarrow Ad(IR)$

##### 执行周期微操作的节拍安排

我们来分析执行周期中介绍的十条微指令的节拍安排，他们中的大部分都十分简单，只消一条微指令足矣。故这里直接给出总结性的表格。

| 编号 | 指令  |          T0           |      T1      |            T2            |
| :--: | :---: | :-------------------: | :----------: | :----------------------: |
|  ①   |  CLA  |                       |              |          0 ⟶ AC          |
|  ②   |  COM  |                       |              |         AC ⟶ AC          |
|  ③   |  SHR  |                       |              | L(AC) ⟶ R(AC)<br>AC ⟶ AC |
|  ④   |  CSL  |                       |              | R(AC) ⟶ L(AC)<br>AC ⟶ AC |
|  ⑤   |  STP  |                       |              |          0 ⟶ G           |
|  ⑥   | ADD X | Ad(IR) ⟶ MAR<br>1 ⟶ R | M(MAR) ⟶ MDR |    (AC) + (MDR) ⟶ AC     |
|  ⑦   | STA X | Ad(IR) ⟶ MAR<br>1 ⟶ W |   AC ⟶ MDR   |       MDR ⟶ M(MAR)       |
|  ⑧   | LDA X | Ad(IR) ⟶ MAR<br>1 ⟶ R | M(MAR) ⟶ MDR |         MDR ⟶ AC         |
|  ⑨   | JMP X |                       |              |       Ad(IR) ⟶ PC        |
|  ⑩   | BAN X |                       |              |  A₀·Ad(IR) + A₀·PC ⟶ PC  |

CLA等这些简单指令不一定要放在T~2~中，T~0~\~T~2~均可。

##### 中断周期微操作的节拍安排

我们来回忆一下中断周期的三个操作：

1. 保存断点
2. 形成中断服务程序入口地址，假设用硬件向量法实现
3. 关中断，即中断允许触发器置0

基于以上步骤，我们来安排中断周期的微指令节拍。

1. T~0~

   $0\rightarrow MAR$

   $1\rightarrow W$

   硬件关中断

2. T~2~

   $PC\rightarrow MDR$

3. T~3~

   $MDR\rightarrow M(MAR)$

   $向量地址\rightarrow PC$

   中断隐指令完成

#### 组合逻辑设计步骤

“非常简单”，只要用逻辑表达式写出任何一个控制信号产生的条件，再进行硬件实现就可以了。

所以我们首先需要列出操作时间表，把所有可能的微操作列在微操作命令信号列表里。

##### 列出操作时间表

列出组合程序逻辑表格如下

![组合程序设计表2.drawio](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/%E7%BB%84%E5%90%88%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%A1%A82.drawio.svg)



##### 写出微操作命令的最简表达式

根据表格，结合数字逻辑的知识，很容易写出并化简微操作指令对应的最简表达式。

比如$M(MAR)\rightarrow MDR$

$\begin{array}{l}
=\mathrm{FE} \cdot T_{1}+\mathrm{IND} \cdot T_{1}(\mathbf{A D D}+\mathrm{STA}+\mathrm{LDA}+\mathrm{JMP}+\mathbf{B A N}) \\
+\mathrm{EX} \cdot T_{1}(\mathbf{A D D}+\mathrm{LDA}) \\
=T_{1}\{\mathrm{FE}+\mathrm{IND}(\mathbf{A D D}+\mathrm{STA}+\mathrm{LDA}+\mathrm{JMP}+\mathrm{BAN}) \\
+\mathbf{E X}(\mathbf{A D D}+\mathbf{L D A})\} \\
\end{array}$

##### 画出逻辑图

根据最简表达式，就可以做出对应的硬件连接图。

![image-20240706160526603](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20240706160526603.png)

##### 小结

组合逻辑设计，这种方法即首先列出操作指令表，然后对指令对应的最简表达式，最后根据表达式作图。

这种方法有以下三个特点：

- 思路清晰，简单明了，任何一个控制信号都可以写出逻辑表达式
- 庞杂，调试困难，修改困难（因为都是硬件电路）
- 速度快，RISV精简指令集即采用这种设计方法；CPU支持整型运算和浮点运算，其中整型运算也采用组合逻辑CU

### 微程序设计

微程序设计的方法是由1951年英国剑桥大学教授Wilkes提出的，这种方法非常适合指令扩展。

我们知道，不同节拍下发出的控制命令是有先后顺序的，控制命令实际上就是一个或者几个电信号，由这些电信号去控制部件执行相应的操作。

微程序设计的思想就是把这些电信号储存起来，存储器存储的0或1数据，代表一个节拍下组成控制命令的高低电平信号，我们可以利用这些高低电平信号来表示一个节拍中我们要发出的控制命令。所以我们把微指令保存在ROM中，执行时一条一条读出，微指令的先后顺序就是微操作执行的先后顺序，根据每条微指令有效信号的个数和位数发出相应的微操作命令。

因此，微程序设计又称**存储逻辑方式**，即把逻辑信号存储在存储器中。

可以参照下图理解：

<img src="https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20240706163101937.png" alt="image-20240706163101937" style="zoom:50%;" />

一个指令周期包含多个机器周期，一条机器指令对应一个微程序，微程序对应的是一系列微指令，一条微指令又对应一系列的微操作命令。

#### 微程序控制单元基本框图

以下是微程序控制单元设计的基本框图。

<img src="https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20240706163801863.png" alt="image-20240706163801863" style="zoom:50%;" />

- 核心是控制存储器，保存微指令。执行时要知道微指令的地址，地址保存在控制存储器地址寄存器（CMAR）中，读出的微指令放入CMDR。
- 每条指令执行阶段对应的微操作是不一样的，所以微程序首地址也是不一样的。
- 根据执行的指令，确定微程序在控制存储器中的首地址，所以还需要微地址形成部件。
- 顺序逻辑：CMAR中的地址有多个来源，用顺序逻辑选择一个正确的来源。
- 操作控制：一串0和1，其中1代表对应的微操作命令。
- 顺序控制：给出下一条微指令的地址

整体操作类似于计算机访存，都有MAR（CMAR）和MDR（CMDR）寄存器。只不过控制存储器在CPU内部，所以访问速度会比一般的访存更快。

在控制存储器中，结构框图如下：

<img src="https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20240706164304889.png" alt="image-20240706164304889" style="zoom:50%;" />

M+2的下地址不一定是M+3，如果直接进入执行周期，根据指令译码才能指导是什么指令，该执行哪里的微程序，需要依赖微地址形成部件得到下条微指令地址，所以M+2的下地址为XXX。

#### 工作原理

我们通过执行以下指令来演示微程序设计的工作原理。

```assembly
LDA X
ADD Y
STA Y
STP
```

##### 取指阶段

此阶段执行取指微程序

1. $M\rightarrow CMAR$

   $CM(CMAR)\rightarrow CMDR$

   $CMDR$发出命令

   形成下一条微指令地址$M+1$

2. $Ad(CMDR)\rightarrow CMAR$

   $CM(CMAR)\rightarrow CMDR$

   $CMDR$发出命令

   形成下一条微指令地址$M+2$

3. $Ad\rightarrow CMAR$

   $CM(CMAR)\rightarrow CMDR$

   $CMDR$发出命令

   由于下地址为$XXX$，表示下一条微指令的地址不能由下地址给出，而是要进入到间址阶段或执行阶段

##### 执行阶段

此阶段执行LDA微程序

1. $OP(IR)\rightarrow 微地址形成部件\rightarrow CMAR  （P\rightarrow CMAR）$

   $CM(CMAR)\rightarrow CMDR$

   $CMDR$发出命令

   形成下一条微指令地址$P+1$

2. $Ad(CMDR)\rightarrow CMAR$

   $CM(CMAR)\rightarrow CMDA$

   $CMDA$发出命令

   形成下一条微指令地址$P+2$

3. $Ad(CMDR)\rightarrow CMAR$

   $CM(CMAR)\rightarrow CMDR$

   $CMDR$发出命令

   形成下一条微指令地址$M\rightarrow CMAR$

##### 取指阶段

继续执行取指微程序，得到下一条指令

……

##### 小结

通过以上工作原理的实例，我们知道：全部的微指令都保存在CM中，程序执行过程中只需要读出指令。而这一系列操作关键在于：

-  微指令的操作控制字段如何形成微操作命令
-  微指令的后续地址如何形成

所以接下来我们来介绍微程序设计如何对微指令进行编码，以及如何形成后续地址。

#### 微指令的编码方式

##### 直接编码方式

即在微指令的操作控制字段中，每一位代表一个微操作命令，某位为“1”代表该控制信号有效。

<img src="https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20240706171522749.png" alt="image-20240706171522749" style="zoom:50%;" />

这种方式特点在于：

- 速度最快，不需要译码，且设置多个位为“1”可以实现并行处理
- 由于每一位都要对应一条微指令，所以微指令需要有2^n^位（假设操作码有n位，对应的译码位数就有2^n^位）

##### 字段直接编码方式

将微指令的控制字段氛围若干个“段”，每段经过译码后发出控制信号。注意每个译码器一次只能有一个输出为1，因此分到一段中的微操作应当是互斥的。

<img src="https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20240706171918592.png" alt="image-20240706171918592" style="zoom:50%;" />

这种方式特点在于：

- 显示编码
- 缩短了微指令字长，原来需要2^n^位，现在每段中仅需要n为即可，然后再通过译码解释为2^n^位
- 由于增加了译码时间，所以微程序执行速度较慢

##### 字段间接编码方式

即隐式编码，这种编码方式译码时还需要以来其他译码器的译码结果，所以是间接编码。

<img src="https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20240706172325957.png" alt="image-20240706172325957" style="zoom:50%;" />

##### 混合编码

即直接编码和字段编码（直接和间接）混合使用。对于常用的微指令，我们可以采取直接编码加快执行速度；对于不常用的微指令，我们可以用字段编码来减少微指令字长。

#### 微指令序列地址的形成

有以下几种方法：

1. 微指令的下地址字段指出

2. 根据机器指令的操作码形成

3. 增量计数器

   即通常情况下微指令的下地址指向的都是连续的下一条地址，此时只需要把CMDA中的地址+1，而无需将CMDR中的地址部分取回CMDA中

4. 分支转移

   即遇到跳转情况时

   <img src="https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20240706172828439.png" alt="image-20240706172828439" style="zoom:50%;" />

5. 通过测试网络

   可以用于微程序在小范围内的跳转

   <img src="https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20240706172904041.png" alt="image-20240706172904041" style="zoom:50%;" />

6. 由硬件产生微程序入口地址

   比如第一条微指令地址由专门硬件产生，告诉计算机去取指令

   比如中断周期中由硬件产生的中断周期微程序的首地址

经过以上介绍，我们可以把影响微程序序列地址形成的因素归纳如下图所示：

<img src="https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20240706173047643.png" alt="image-20240706173047643" style="zoom:50%;" />

注意，分支逻辑产生的信号控制多路选择器，由于判断是否发生跳转，转移方式也要送入分支逻辑。

#### 微指令格式

简答题来咯，注意辨析水平型微指令和垂直型微指令的异同。

- 水平型微指令：即一次能定义并执行多个并行操作。

  如直接编码、字段直接编码、字段间接编码、直接和字段混合编码

- 垂直型微指令：复杂的微操作，操作间有先后次序。

  一次只能定义一个操作，类似机器指令操作码的方式，由微操作码字段规定微指令的功能

两者的比较：

- 水平型微指令比垂直型微指令并行操作能力强，灵活性强
- 水平型微指令执行一条机器指令所要的微指令数目少，速度快
- 水平型微指令用较短的微程序结构换取较长的微指令结构
- 水平型微指令与机器指令差别大

| 特点       | 垂直型微指令 (Vertical Microinstruction) | 水平型微指令 (Horizontal Microinstruction) |
| ---------- | ---------------------------------------- | ------------------------------------------ |
| 指令长度   | 窄位指令，使用操作码编码控制信号         | 宽位指令，每位或每组位直接控制硬件信号     |
| 并行性     | 较低，通过解码器生成的控制信号较少       | 高，可以同时激活多个控制信号               |
| 灵活性     | 相对较低，通过解码器生成控制信号         | 高，可以更细粒度地控制硬件部件             |
| 实现复杂性 | 需要解码器来解释操作码，设计更为复杂     | 实现相对简单，直接控制信号                 |
| 适用场景   | 适用于需要节省指令存储空间的场合         | 适用于需要高并行性的场合                   |

> ## 例子
>
> ### 水平型微指令 (Horizontal Microinstruction)
>
> 假设有以下控制信号：
>
> - 读取内存：Memory Read (MR)
> - 写入内存：Memory Write (MW)
> - 加载累加器：Load Accumulator (LA)
> - 存储累加器：Store Accumulator (SA)
>
> 示例微指令：
>
> | MR   | MW   | LA   | SA   |
> | ---- | ---- | ---- | ---- |
> | 1    | 0    | 1    | 0    |
>
> 这条微指令表示同时进行“读取内存”和“加载累加器”的操作。
>
> ### 垂直型微指令 (Vertical Microinstruction)
>
> 假设有以下操作码和对应的控制信号：
>
> - 00: 读取内存 (MR) 
> - 01: 写入内存 (MW) 
> - 10: 加载累加器 (LA) 
> - 11: 存储累加器 (SA)
>
> 示例微指令：10
>
> 这条微指令通过解码器生成控制信号“加载累加器”。

#### 静态和动态微程序设计

静态微程序设计，即微程序无须改变，直接存储在ROM中。

动态微程序设计，允许修改、扩展指令集，通过修改微程序的方式，在控制存储器中写入新的指令在执行阶段的微程序。一般为了保证兼容性，很少进行修改，而是直接扩展。

十分有利与指令仿真。增加或修改一条指令，看下改变之后的体系结构运行某类应用程序性能是否较大提升，生成下批处理器时，就可以改变指令集

一般采取EPROM。

#### 毫微程序设计

毫微程序概念的理解可以参考微程序和机器指令的关系：

- 微程序设计用微程序解释机器指令
- 毫微程序设计用毫微程序解释微程序

当微指令比较复杂，并且这个操作内部的毫微操作也有一定的先后顺序时，就需要考虑毫微程序的设计。

<img src="https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20240706194837556.png" alt="image-20240706194837556" style="zoom:50%;" />

这里放出毫微程序的设计结构图进行参考，并不是重点，仅做了解。

可以看到，毫微程序设计和微程序设计之间类似套娃的关系，又是一层新的抽象。

#### 串行和并行微程序控制

参考下图：

<img src="https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20240706195032652.png" alt="image-20240706195032652" style="zoom:50%;" />

可以通过流水的方式加快微指令执行效率。

#### 微程序设计举例

最后的波纹了！

照例，我们需要先对指令的每个阶段进行微操作分析，然后再画出码点图。假设CPU结构和组合逻辑相同，且为非总线结构。

##### 写出对应机器指令的微操作及节拍安排

这里只给出取值周期和执行周期中的节拍安排，整理列表如下：

取指周期：

| 时间周期 | 微操作                                                       |
| -------- | ------------------------------------------------------------ |
| T0       | PC → MAR / 1 → R                                             |
| T1       | <font style="color:red">Ad(CMDR) → CMAR</font>               |
| T2       | M(MAR) → MDR / (PC)+1 → PC                                   |
| T3       | <font style="color:red">Ad(CMDR) → CMAR</font>               |
| T4       | MDR → IR / OP(IR) → 微地址形成部件                           |
| T5       | <font style="color:red">OP(IR) → 微地址形成部件 → CMAR</font> |



执行周期：

执行阶段最后一条微指令的下地址应当是M，需要把下地址取出送入CMAR

| 指令 | 时间周期 | 微操作                                         |
| ---- | -------- | ---------------------------------------------- |
| CLA  | T0       | 0 → AC                                         |
|      | T1       | <font style="color:red">Ad(CMDR) → CMAR</font> |
| COM  | T0       | AC → AC                                        |
|      | T1       | <font style="color:red">Ad(CMDR) → CMAR</font> |
| SHR  | T0       | L(AC) → R(AC) / AC0 → AC0                      |
|      | T1       | <font style="color:red">Ad(CMDR) → CMAR</font> |
| CSL  | T0       | R(AC) → L(AC) / AC0 → ACn                      |
|      | T1       | <font style="color:red">Ad(CMDR) → CMAR</font> |
| STP  | T0       | 0 → G                                          |
|      | T1       | <font style="color:red">Ad(CMDR) → CMAR</font> |
| ADD  | T0       | Ad(IR) → MAR / 1 → R                           |
|      | T1       | <font style="color:red">Ad(CMDR) → CMAR</font> |
|      | T2       | M(MAR) → MDR                                   |
|      | T3       | <font style="color:red">Ad(CMDR) → CMAR</font> |
|      | T4       | (AC) + (MDR) → AC                              |
|      | T5       | <font style="color:red">Ad(CMDR) → CMAR</font> |
| STA  | T0       | Ad(IR) → MAR / 1 → W                           |
|      | T1       | <font style="color:red">Ad(CMDR) → CMAR</font> |
|      | T2       | AC → MDR                                       |
|      | T3       | <font style="color:red">Ad(CMDR) → CMAR</font> |
|      | T4       | MDR → M(MAR)                                   |
|      | T5       | <font style="color:red">Ad(CMDR) → CMAR</font> |
| LDA  | T0       | Ad(IR) → MAR / 1 → R                           |
|      | T1       | <font style="color:red">Ad(CMDR) → CMAR</font> |
|      | T2       | M(MAR) → MDR                                   |
|      | T3       | <font style="color:red">Ad(CMDR) → CMAR</font> |
|      | T4       | MDR → AC                                       |
|      | T5       | <font style="color:red">Ad(CMDR) → CMAR</font> |
| JMP  | T0       | Ad(IR) → PC                                    |
|      | T1       | <font style="color:red">Ad(CMDR) → CMAR</font> |
| BAN  | T0       | $A_0·Ad(IR)+\overline{A_0}·(PC)\rightarrow PC$ |
|      | T1       | <font style="color:red">Ad(CMDR) → CMAR</font> |

上述共有20个微操作，38条微指令。

如果用水平型编码，直接编码，每一个微操作都需要操作控制字段中1位来表示。要在控制存储器内寻址，下地址字段长度和控制存储器大小相关，38条微指令需38个存储单元。

##### 确定微指令格式

- 假设微指令的编码方式：采取水平直接控制

- 后续微指令的地址形成方式：

  由机器指令的操作码通过微地址形成部件形成

  由微指令的下地址字段直接给出

- 微指令字长

  由20个微操作，确定操作控制字段最少为20位

  由38条微指令，确定微指令的下地址字段为6位

  微指令字长可取$20+6=26$位

- 微指令字长的优化

  38条微指令中有19条是关于后续微指令地址 → CMAR

  $\text { 其中 }\left\{\begin{array}{lr}
  1 \text { 条 } & \text { OP }(\text { IR }) \longrightarrow \text { 微地址形成部件 } \longrightarrow \text { CMAR } \\
  18 \text { 条 } & \text { Ad ( CMDR }) \longrightarrow \text { CMAR }
  \end{array}\right.$

  若用Ad(CMDR)直接送入控存地址线，即省略CMAR，则可以省略掉以上19条指令，2个微操作。

  <img src="https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20240706203838160.png" alt="image-20240706203838160" style="zoom:50%;" />

  此时微指令：$38-19=19$ 下地址字段最少5位

  此时微操作：$20-2=18$ 操作控制字段最少18位

  考虑留有一定的容量方便后续扩展，有：$\left.\begin{array}{lr}
  \text { 取操作控制字段 } & 18 \text { 位 } \rightarrow 24 \text { 位 } \\
  \text { 下地此字段 } & 5 \text { 位一 } 6 \text { 位 }
  \end{array}\right\} \text { 共 } 30 \text { 位 }$

- 定义微指令操作字段每一位的操作

  <img src="https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20240706204036976.png" style="zoom:50%;" />

##### 编写微指令码点

规定每一位的操作如下（部分）：

![image-20240706204256674](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20240706204256674.png)

画出码点图

![image-20240706204429307](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20240706204429307.png)

即根据划分的节拍和规定的操作标1，最后即可得到微指令对应的码点。

……

……

本博客的内容就到此结束了，希望能帮助你更深刻的理解计算机组成原理这门课程，该说不说还挺有意思的。

那么，完结撒花:white_flower::white_flower:ヽ(°▽°)ノ:white_flower: 

---

![C10AD1752A521C3C297E7D81400952F1](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/C10AD1752A521C3C297E7D81400952F1.jpg)
