---
title: Coursera-ML-AndrewNg-Notes-Week3
date: 2024-11-07 10:54:12
updated: 2024-11-07 10:54:12
tags:
  - Logical Regression
  - Regularization
categories: Machine-Learning
cover: https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/110028263_p0.jpg
description: Learning logical regression and explaining how to use reularization to solve the problem of overfitting.
---


{% span center logo large, Coursera-ML-AndrewNg-Notes-Week3 %}

{% span center small, My machine learning notes %}

这里是吴恩达机器学习视频的Week3部分，笔记如下。

这周的主题是逻辑回归。

在要求输出二元的离散预测结果时，线性回归的拟合效果很差。所以我们引入了逻辑回归，是目前最为流行的一种广泛应用于统计学和机器学习的预测分析方法。尽管它的名字中有“回归”二字，但它实际上是一种分类算法，特别是用于二分类问题。此外，还介绍了机器学习中欠拟合和过拟合的问题，以及用于解决过拟合问题的正则化方法。

视频链接在下方：

{% btn 'https://www.bilibili.com/video/BV1Bq421A74G?spm_id_from=333.788.videopod.episodes&vd_source=5e421b52b9103cce8e012430aa932553',Machine Learning Specialization,far fa-hand-point-right,block center larger %}

## Logistic Regression

### Classification

在前两周，我们学习了线性回归的方法来预测数据，比如房价预测模型。但如果应用场景要求给出二元离散结果的预测值（即二元分类问题），线性回归方程得到的结果较差。

让我们假设有以下场景：区别一个肿瘤是恶性的还是良性的。

给定数据集包含肿瘤的大小与检测结果键值对，检测结果作为因变量。因变量可能属于两个类：正向类或负向类。为了表示方便起见，我们用$0$表示负向类，$1$表示正向类，即$y\in 0,1$。如果使用线性回归方程进行模拟，得到的图像可能如下所示：

<img src="https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20241104111149863.png" alt="image-20241104111149863" style="zoom:50%;" />

我们的输出只要求出现$0$或$1$两种情况，但线性回归方程是连续的，它可能会输出$0.7$，这时该怎么解释结果呢？也许我们可以通过设置一个决策边界来解决：定义模型输出大于$0.5$的结果为$1$，而输出小于$0.5$的结果为$0$。

但是，这又会出现新的问题：假如此时出现了一个远远偏离于原回归直线方程的数据点。

<img src="https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20241104113514713.png" alt="image-20241104113514713" style="zoom: 33%;" />

那么，此时的回归直线方程将发生改变，导致决策边界产生**偏移**。在原来的情况，纵轴$0.5$可能对应于决策边界横轴的$x$cm，但加入一个新的数据点后，新的决策边界可能变为$x+a$cm。可以看到原来的恶性数据点在新的情况中将被模型错误地预测为良性，这是不可接受的。

为了解决二分类问题，我们引入逻辑回归算法，这可能是世界上应用最广泛的分类算法。

{% note info simple %}
你可能会问：为什么不用非线性回归方程呢？

的确，非线性回归方程比线性回归方程更加灵活，在某种程度上也能取得比线性回归方程更好的效果。然而非线性回归方程仍然面临输出范围与模型选择的问题，需要更多的参数调整，也更为复杂。所以，仍然不如使用逻辑回归。
{% endnote %}

### Hypothesis Representation

引入逻辑回归，模型假设是：$h_{\theta}(x) = g(\theta^T X)$。其中$X$代表特征向量，$g$代表逻辑函数。一般$g$取$Sigmoid$函数，公式为$g=\frac{1}{1+\mathrm{e}^{-z}}$。

该函数的图像如下所示：

![image-20241104115444634](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20241104115444634.png)

不难发现，当$z$是一个很大的数时，输出将无限趋近于$1$；当$z$是一个很小的数时，结果相反。

将逻辑函数代入模型中，得完整的模型为：
$$
h_{\theta}(x)=\frac{1}{1+\mathrm{e}^{-\theta^T X}}
$$
回到肿瘤预测的情形下。在参数确定的情况下，这个模型的输入$x$是肿瘤的大小，模型的输出$y$是预测该肿瘤为恶性或良性的概率。比如$h_{\theta}(x)=0.7$，说明输入有$70\%$的概率为$1$，有$1-\%70=30\%$的概率为$0$。

一般，我们约定用如下式子来表示“模型预测”：
$$
h_{\theta}(X)=P(y=1|X;\theta)
$$
即该模型输出：给定输入$X$与参数$\theta$时，$y=1$的概率。

### Decision Boundary

在前面我们提了一嘴决策边界，现在我们来详细的讲讲这一点，来理解逻辑回归到底是在干什么。

在逻辑回归中，我们预测如下：

- 当$h_{\theta}(x)≥0.5$时，预测$y=1$
- 当$h_{\theta}(x)＜0.5$时，预测$y=0$

代入$g(z)$中，可得：

- 当$z≥0$时，$g(z)≥0.5$,，此时预测$y=1$
- 当$z<0$时，$g(z)<0.5$,，此时预测$y=0$

将$z$展开，以得到关于$\theta$和$X$的一个不等式。即：

- $\theta X≥0$时，预测$y=1$
- $\theta X<0$时，预测$y=0$

为便于展示，我们假设有一个模型，它具有两个特征。此时$g(\theta X)=(\theta_0+\theta_1x_1+\theta_2x_2)$。假设$\theta=[-3,1,1]$，则当$\theta X=-3+x_1+x_2≥0$时，预测$y=1$。

<img src="https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20241106102132463.png" alt="image-20241106102132463" style="zoom:67%;" />

做出方程$-3+x_1+x_2=0$所对应的直线，该直线就是决策边界。可以看到，决策边界划分了数据集，在直线上方（$\theta X=-3+x_1+x_2≥0$）的数据被预测为$y=1$，而在直线下方（$\theta X=-3+x_1+x_2<0$）的数据则被预测为$y=0$。

需要注意的是，逻辑回归模型的决策边界通常是直线的，因为它通过一个线性函数（即 $\theta X$）来进行分类。但如果数据集分类长的像下图所示呢？

<img src="https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20241106102958257.png" alt="image-20241106102958257" style="zoom:67%;" />

可以通过特征变换引入二次项特征来拟合更复杂的模型边界。比如可以引入特征向量$X=[x_1,x_2,x_1^2,x_2^2,x_1x_2]$，设置模型参数为$\theta=[-1,0,0,1,1,0]$。此时$g(\theta X)=(x_1^2+x_2^2-1)$，决策边界为$x_1^2+x_2^2=1$，是一个半径为$1$的圆。

如果需要适应更加复杂的决策边界，可以引入更复杂的模型。

### Loss Function

在线性回归中，我们是通过梯度下降法计算代价函数$J(\theta)$的最小值情况来优化参数$\theta$。但是在逻辑回归中，不能够直接套用线性回归的优化方法。

对于线性回归，其代价函数$J(\theta)$定义为所有模型误差的平方和。
$$
J(\theta) = \frac{1}{2m} \sum_{i=1}^{m} \left( h_\theta(x^{(i)}) - y^{(i)} \right)^2
$$
从理论上来说，我们可以继续在逻辑回归中套用这个代价函数。但是当我们将$Sigmoid$函数带入到$h_{\theta}(x)$中时，得到的代价函数将是一个非凸函数，且图像将出现“震荡”。

<img src="https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20241106104123798.png" alt="image-20241106104123798" style="zoom:67%;" />

这意味着此时$J(\theta)$将出现多个局部最小值，梯度下降函数将很难找到全局最小值来得到最优的参数$\theta$。这是因为由于$Sigmoid$函数输出的非线性性质，即使是输入小的变化，也可能导致输出较大的变化，从而使得误差的平方波动幅度增大。

{% note info simple %}

sigmoid 函数的性质使得：

- 当输出接近 0 或 1 时，导数趋近于 0，导致误差对参数的敏感性降低。
- 当输出接近 0.5 时，导数达到最大，导致误差对参数变化的敏感性增强。

{% endnote %}

于是，我们重新定义逻辑回归的代价函数为：
$$
J(\theta) = \frac{1}{m} \sum_{i=1}^{m} \operatorname{L}(h_{\theta}(x^{(i)}), y^{(i)})
$$

$$
\operatorname{L}(h_{\theta}(x), y) = 
\begin{cases}
-\log(h_{\theta}(x)) & \text{if } y=1 \\
-\log(1-h_{\theta}(x)) & \text{if } y=0
\end{cases}
$$

其中$\operatorname{L}$代表损失函数$\operatorname{LOSS}$。

{% note info simple %}

你可以能会好奇，这个$\operatorname{LOSS}$函数是怎么得到的呢？答案是运用了统计学中的最大似然法，读者可以自行前往了解。

{% endnote %}

这个函数很有意思，我们观察一下$\operatorname{L}(h_{\theta}(x), y)$和$h_{\theta}(x)$的图像。

![image-20241106105525489](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20241106105525489.png)

可以看到，新的代价函数意义在于：

- 当实际的结果为$y=1$时，随着$h_{\theta}(x)$的增大，损失将无限趋近于$0$；反之，则损失无限接近于无穷大。
- 当实际的结果为$y=0$是，随着$h_{\theta}(x)$的减小，损失将无限趋近于$0$；反之，则损失无限接近于无穷大。

$h_{\theta}(x)$即模型预测$y=1$的概率，所以新的代价函数能够很好的描绘出$Sigmoid$函数的损失情况。将构建的$\operatorname{L}(h_{\theta}(x), y)$函数简化如下：
$$
\operatorname{L}(h_{\theta}(x), y) = -y \log(h_{\theta}(x)) - (1 - y) \log(1 - h_{\theta}(x))
$$
代入到代价函数中，得到逻辑回归的代价函数为：
$$
J(\theta) = -\frac{1}{m} \sum_{i=1}^{m} \left[ y^{(i)} \log(h_{\theta}(x^{(i)})) + (1 - y^{(i)}) \log(1 - h_{\theta}(x^{(i)})) \right]
$$
更重要的是，该函数是一个凸函数。如果计算该函数的二阶导数，可以证明其恒大于0。这意味着在优化过程中，任何局部最小值也是全局最小值，提供了更好的收敛性和稳定性。

<img src="https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20241106110510462.png" alt="image-20241106110510462" style="zoom: 67%;" />

### Gradient Descent

既然我们现在有了新的代价函数，我们就可以对其运用梯度下降法来求解最小参数$\theta$。新的代价函数是：
$$
J(\theta) = -\frac{1}{m} \sum_{i=1}^{m} \left[ y^{(i)} \log(h_{\theta}(x^{(i)})) + (1 - y^{(i)}) \log(1 - h_{\theta}(x^{(i)})) \right]
$$
对其运用梯度下降法，即特征向量的每个元素$\theta_j$减去学习率$\alpha$与$J(\theta)$关于$\theta_j$微分项的乘积。
$$
\theta_j = \theta_j - \alpha \frac{\partial}{\partial \theta_j} J(\theta, b)
$$
对其求导后得到：
$$
\theta_{j} = \theta_{j} - \alpha \frac{1}{m} \sum_{i=1}^{m} \left( h_{\theta}(x^{(i)}) - y^{(i)} \right) x_{j}^{(i)}
$$
{% note danger simple %}

你可能会发现一个事实：逻辑回归的梯度下降系数计算法在形式上和线性回归中是一样的。但是要注意这两个并不是同一个算法，因为彼此对$h_{\theta}(x)$的定义不一样。

在线性回归中，$h_{\theta}(x) = \theta^{T} X = \theta_{0} x_{0} + \theta_{1} x_{1} + \theta_{2} x_{2} + \cdots + \theta_{n} x_{n}$

在逻辑回归中，$h_\theta(x) = \frac{1}{1 + e^{-\theta^T x}}$

{% endnote %}

这就是逻辑回归算法的全部内容：代价函数与其优化策略。需要注意的是，逻辑回归仍然通用线性回归的一些优化技巧，比如监测梯度下降、提倡向量化计算$\theta$与特征缩放。

### Multiclass Classification_ One-vs-all

我在b站看的视频资源里没有包含这一节的内容，但是GitHub上的笔记却有。所以这一节可以算作拓展，有兴趣的读者可以了解一下，我个人也觉得这一节的内容很有用。

我们先前已经学习了如何通过逻辑回归解决二分类问题，但如果我们需要进行多分类呢？比如一个病人因为鼻塞来到你的诊所，他可能并没有生病，用𝑦=1这个类别来代表；或者患了感冒，用𝑦=2来代表；或者得了流感用𝑦=3来代表。

显而易见继续沿用二分类模型将无法解决问题，因为逻辑回归只存在正负（或者是0 1）两种预测状态。比较直观的理解是当你有两个特征时，决策边界是一条直线——它只能将数据集划分为两片区域，而多分类时你的数据集看起来将像这样。

![image-20241106225506944](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20241106225506944.png)

如何处理多分类问题？其实要处理起来也很简单，简单到用一句话就能概括：{% span red,运用多次二元分类  %}。更具体的说，当我们在处理三角形数据时，可以把叉叉元素和矩形元素视为同一种结果，即非三角形元素。同理，对剩下两个元素也可以进行类似的处理，{% span yellow,最终得到的效果等同于在数据集上画出三条决策边界 %}。

![image-20241106230159172](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20241106230159172.png)

所以，我们的处理方法是：

- 依次建立多个分类器$h_{\theta}^i(x)$，将得到的一系列模型标记为$h_{\theta}^i(x)=p(y=i|x;\theta)$，其中$i=(1,2,3\cdots k)$
- 在需要进行预测时，将所有分类机都运行一遍，然后对每一个输入变量，选择可能性最大的输出变量，即变量的最终预测结果为$\max_i h_\theta^{(i)}(x)$

这就是多类别分类问题，以及一对多的方法，通过这个小方法，你现在也可以将逻辑回归分类器用在多类分类的问题上。

## Regularization

### The Problem of Overfitting

现在我们来讨论过拟合（Overfitting）的问题，来看以下三幅图。

<img src="https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20241107092519177.png" alt="image-20241107092519177" style="zoom: 50%;" />

第一幅图采取线性回归模型去拟合数据，可以看出来拟合效果并不是很好。有一些数据点距离回归直线的距离较远，意味着此时的代价函数仍然是比较大的。这种情况我们称之为{% span yellow,欠拟合（Underfit） %}，也就是说此时我们的模型不能很好的拟合训练集。

第二幅图采取非线性回归模型去拟合数据，此时的拟合效果刚刚好。可以看到二次函数曲线差不多刚好经过了每个数据点，此时的代价函数相对欠拟合较小。这种情况没有特定的称呼，但我们可以叫它{% span green,刚刚好（Just right） %}。

第三幅图就很耐人寻味了。它使用了大量高维的特征去拟合数据，甚至可以使得拟合曲线恰好经过每一个数据点。也就是说，在引入大量特征后，我们甚至可以把代价函数降为0。不过从图像上来看，这个模型显然太准确了，它过于强调拟合原始数据，而丢失了算法的本质，导致其在预测新数据时会表现的很差。这种情况，我们就称之为{% span red,过拟合（Overfit） %}。

分类问题中也存在过拟合的问题，观察以下三幅图。

<img src="https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20241107093441097.png" alt="image-20241107093441097" style="zoom:50%;" />

从多项式的角度来说可以总结如下：$x$的次数越高，拟合效果越好，但相应的可预测能力就会变差。问题在于，我们如何处理过拟合现象呢？这就是我们下半篇要讨论的问题，一般来说有三种办法：

- 收集更多数据，增加原始训练集的数量，但在大部分情况下，我们往往无法收集到更多数据。
- 丢弃一些特征，减少特征数量。我们可以手工凭经验丢弃一些不重要的特征，或者是借助一些算法来帮助我们自动丢弃掉一些特征。
- 运用正则化处理模型。正则化不会减少特征数量，但是会减小参数大小（仅限L2正则化，后续会补充）。

### Cost Function With Regularization

在上面我们过拟合的线性回归采用的模型是：
$$
h_{\theta}(x) = \theta_{0} + \theta_{1} x_{1} + \theta_{2} x_{2}^{2} + \theta_{3} x_{3}^{3} + \theta_{4} x_{4}^{4}
$$
从过拟合与正常情况的对比可以看出，正式$x_3^3$与$x_4^4$这两个高次项导致了过拟合的产生。如果我们能够让这些高次项的系数接近$0$的话，就可以很好的避免高次项的影响。当然我们也可以直接对参数取$0$，此时该模型将退化至二次项的刚刚好模型。直接丢弃这些高维特征固然是一个不错的选择，但我们如果要保留这些特征呢？那就需要用到正则化了。

要减少$\theta_3$与$\theta_4$的值，我们要做的就是对这两个参数设置一点惩罚。具体来说，就是在代价函数中可以做些手脚：
$$
J(\theta)=\frac{1}{2m}[\sum_{i=1}^{m} \left( h_{\theta}(x^{(i)}) - y^{(i)} \right)^2 + 1000 \theta_{3}^2 + 1000 \theta_{4}^2]
$$
我们在代价函数中手动加上了$1000\theta_3^2$与$1000\theta_4^2$，这样$\theta_3$与$\theta_4$只要增加一点点就会引起代价函数的剧烈变化。从而达到要使得代价函数最小，必须要压制这两个参数的效果。这样通过代价函数选择出来的参数，对预测结果的影响就会比之前小很多。这里的$1000$并没有具体要求，它代表是一个很大的数，使用时根据具体情况具体选择。

但现实情况往往是我们并不知道该选择哪个参数进行惩罚，于是我们可以采取**对所有参数进行惩罚**的方式，实践证明对所有参数进行惩罚最后得到的拟合曲线往往更加平滑，预测效果也更好。我们对上面的代价函数进行拓展，得到一个带惩罚参数的代价函数。
$$
J(\theta) = \frac{1}{2m} \left[ \sum_{i=1}^{m} \left( h_{\theta}(x^{(i)}) - y^{(i)} \right)^2 + \lambda \sum_{j=1}^{n} \theta_{j}^2 \right]
$$
其中$\lambda$代表正则化参数。依照惯例，不对$\theta_0$进行惩罚，因为$x_0$恒为$1$。经过正则化处理的模型图像可能如下：

<img src="https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/image-20241107100350929.png" alt="image-20241107100350929" style="zoom:67%;" />

蓝色的曲线很显然是一个过拟合的图像，应该对其使用正则化处理。然而，如果你的$\lambda$选择不当，可能会导致图像变成图中粉红色的直线。这是因为你的正则化参数$\lambda$太大了，代价函数最终对所有的系数惩罚力度太大，以至于几乎所有的系数都为0，最后的图像只剩下一个常数项。所以，要正确的选择正则化参数$\lambda$，才能得到较好的拟合效果。

### Expanding: L1 and L2 Reularization

如果你有留意前面的内容，你可能会好奇：为什么对惩罚参数的引入是$\theta^2$呢？

你会发现我提到过一个东西叫做**L2正则化**。什么是L2正则化呢？其实就是在对代价函数进行惩罚时，用$\lambda \sum_{j=1}^{n} \theta_{j}^2$的形式，即对惩罚参数的平方引入对参数的惩罚。事实上也的确有**L1正则化**，它是通过$\lambda \sum_{j=1}^{n} |\theta_{j}|$，对惩罚参数的绝对值形式引入的惩罚。问题在于，这两种正则化方式有什么异同吗？

先说结论：

- L1正则化，也叫Lasso回归。它可以产生稀疏权重矩阵，让一些权重可以完全为零，从而实现自动特征选择；并且，它的运用通常是非凸的，会导致优化算法的收敛速度较慢；在多重共线性问题上，L1正则化处理不稳定。
- L2正则化，也叫Ridge回归。它不会让权重压缩到0，所以它不进行特征选择；相反，它倾向于均匀地收缩权重，让它们变小并保持非零，这有助于处理共线性问题。且L2正则化问题总是凸的，这意味着只有一个最小值。这使得优化过程更简单、更稳定。

之所以会导致这种差异，要从数学上做出解释。

L1 正则化引入了绝对值惩罚，这种惩罚在数值上是线性的。由于绝对值函数在零点处不光滑，L1 正则化会导致许多特征系数被强制减小到零。这个特性使得 L1 正则化有助于特征选择，因为它会产生稀疏解，即许多特征的系数为零，从而简化模型。

L2 正则化引入了平方惩罚，这使得惩罚的效果在特征系数较大时更为显著。L2 正则化不会将系数缩减到零，而是会使得所有特征系数变得更小。这个特性促使模型使用所有特征，但抑制了较大的特征系数，从而平滑模型。

由于上述的几何特性和对特征系数的不同影响，L1 和 L2 正则化在实际应用中的效果有显著差异。L1 更适合需要特征选择的场景，而 L2 更适合需要稳定模型的场景。许多实际问题可能会结合两者使用，形成 Elastic Net 正则化，以便同时享有 L1 和 L2 的优点。

### Regularized Linear Regression and Logistic Regression

在学习了怎么对代价函数进行处理来运用正则化后，我们把正则化技术引入线性回归和逻辑回归中。经过正则化处理的**线性回归**代价函数为：
$$
J(\theta) = \frac{1}{2m} \left[ \sum_{i=1}^{m} \left( h_{\theta}(x^{(i)}) - y^{(i)} \right)^2 + \lambda \sum_{j=1}^{n} \theta_{j}^2 \right]
$$
经过正则化处理的**逻辑回归**代价函数为：
$$
J(\theta) = -\frac{1}{m} \sum_{i=1}^{m} \left[ y^{(i)} \log(h_{\theta}(x^{(i)})) + (1 - y^{(i)}) \log(1 - h_{\theta}(x^{(i)})) \right] + \frac{\lambda}{2m} \sum_{j=1}^{n} \theta_{j}^2
$$
对两个代价函数分别运用梯度下降法，得到参数的更新公式：
$$
\theta_{0} = \theta_{0} - a \frac{1}{m} \sum_{i=1}^{m} \left( h_{\theta}(x^{(i)}) - y^{(i)} \right) x_{0}^{(i)}\\
\theta_{j} = \theta_{j} - a \left( \frac{1}{m} \sum_{i=1}^{m} \left( h_{\theta}(x^{(i)}) - y^{(i)} \right) x_{j}^{(i)} + \frac{\lambda}{m} \theta_{j} \right)
$$
对$\theta_j$的更新公式进行重排，可以得到如下公式：
$$
\theta_{j} = \theta_{j} \left(1 - a \frac{\lambda}{m}\right) - a \frac{1}{m} \sum_{i=1}^{m} \left( h_{\theta}(x^{(i)}) - y^{(i)} \right) x_{j}^{(i)}
$$
对比正常的$\theta$参数迭代更新，可以看到，正则化的奥秘就在于每次更新参数时，都会额外的给参数再减少一个额外的值$\left(1 - a \frac{\lambda}{m}\right)$。

线性回归和逻辑回归的参数更新形式是相同的，所以我把它们安排在了一起。但是我们知道，这两个回归模型的$h_{\theta}(x)$不同，所以它们的参数更新规则并不相同。在使用时留意使用正确的$h_{\theta}(x)$就好。

以上就是我们对监督学习的全部内容，主要就介绍了线性回归与逻辑回归，我们也算是在机器学习中一脚迈入了大门。下一周我们将学习神经网络，开始入门深度学习。

---

![110028263_p0](https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/110028263_p0.jpg)
