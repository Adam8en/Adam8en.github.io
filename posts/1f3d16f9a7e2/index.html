<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>LeetCode经典面试150题题解 | Adam8enの8log</title><meta name="author" content="Adam Ben"><meta name="copyright" content="Adam Ben"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="LeetCode面试经典 150 题的个人题解笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode经典面试150题题解">
<meta property="og:url" content="http://example.com/posts/1f3d16f9a7e2/index.html">
<meta property="og:site_name" content="Adam8enの8log">
<meta property="og:description" content="LeetCode面试经典 150 题的个人题解笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/%7B930EB68A-6F85-4666-BA42-9333A5074315%7D.png">
<meta property="article:published_time" content="2024-05-08T12:52:01.000Z">
<meta property="article:modified_time" content="2024-05-08T12:52:01.000Z">
<meta property="article:author" content="Adam Ben">
<meta property="article:tag" content="Go">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/%7B930EB68A-6F85-4666-BA42-9333A5074315%7D.png"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/posts/1f3d16f9a7e2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'LeetCode经典面试150题题解',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-08 20:52:01'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Adam8enの8log" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">58</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw far fa-comment"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/bangumis/"><i class="fa-fw fas fa-tv"></i><span> 追番</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/%7B930EB68A-6F85-4666-BA42-9333A5074315%7D.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Adam8enの8log"><span class="site-name">Adam8enの8log</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw far fa-comment"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/bangumis/"><i class="fa-fw fas fa-tv"></i><span> 追番</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">LeetCode经典面试150题题解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-08T12:52:01.000Z" title="发表于 2024-05-08 20:52:01">2024-05-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-08T12:52:01.000Z" title="更新于 2024-05-08 20:52:01">2024-05-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/LeetCode/">LeetCode</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">16.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>61分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="LeetCode经典面试150题题解"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img gist" style="background-image: url(https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/%7B930EB68A-6F85-4666-BA42-9333A5074315%7D.png)"></div><article class="post-content" id="article-container"><h1 id="88-合并两个有序数组"><a class="markdownIt-Anchor" href="#88-合并两个有序数组"></a> 88. 合并两个有序数组</h1>
<blockquote>
<p>Problem: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-sorted-array/description/">88. 合并两个有序数组</a></p>
</blockquote>
<h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2>
<p>使用“双指针”技术，从两个数组的末尾开始比较元素，然后将较大的元素放入nums1的末尾。这样，我们可以确保nums1在每一步都保持有序。这种方法的关键在于我们从后往前填充nums1，这样就不会覆盖nums1中尚未处理的元素。</p>
<h2 id="解题方法"><a class="markdownIt-Anchor" href="#解题方法"></a> 解题方法</h2>
<ol>
<li>
<p>初始化两个指针 p1 和 p2 到 nums1 和 nums2 的初始元素的最后一个位置上，然后再用一个指针 p 指向 nums1 的最后一个位置。</p>
</li>
<li>
<p>比较 nums1[p1] 和 nums2[p2] 的值，将较大的值放入 nums1[p] 的位置上，然后将 p 指针和较大值的指针都向前移动一位。</p>
</li>
<li>
<p>重复步骤 2，直到 p1 或 p2 小于 0，这意味着 nums1 或 nums2 的元素已经全部放入 nums1 中。</p>
</li>
<li>
<p>如果 p2 还没有小于 0，那么将 nums2 中剩余的元素复制到 nums1 的前面。</p>
</li>
</ol>
<h2 id="复杂度"><a class="markdownIt-Anchor" href="#复杂度"></a> 复杂度</h2>
<p>时间复杂度:<br />
时间复杂度是 O(m+n)，其中m和n分别是 nums1 和 nums2 的长度。在最坏的情况下，我们可能需要遍历 nums1 和 nums2 中的所有元素。因为我们只遍历每个元素一次，所以时间复杂度是线性的。</p>
<p>空间复杂度:<br />
空间复杂度是O(1)。这是因为我们没有使用额外的空间来存储数据。所有的操作都是在原地进行的，我们只是使用了几个额外的变量来保存索引。因此，空间复杂度是常数的。</p>
<h2 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(nums1 []<span class="type">int</span>, m <span class="type">int</span>, nums2 []<span class="type">int</span>, n <span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">    p1:=m<span class="number">-1</span></span><br><span class="line">    p2:=n<span class="number">-1</span></span><br><span class="line">    p:=m+n<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> p1&gt;=<span class="number">0</span> &amp;&amp; p2&gt;=<span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> nums1[p1]&gt;nums2[p2]&#123;</span><br><span class="line">            nums1[p]=nums1[p1]</span><br><span class="line">            p1--</span><br><span class="line">            p--</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            nums1[p]=nums2[p2]</span><br><span class="line">            p2--</span><br><span class="line">            p--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> p2&gt;=<span class="number">0</span>&#123;</span><br><span class="line">        nums1[p]=nums2[p2]</span><br><span class="line">        p--</span><br><span class="line">        p2--</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="27-移除元素"><a class="markdownIt-Anchor" href="#27-移除元素"></a> 27. 移除元素</h1>
<blockquote>
<p>Problem: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element/description/">27. 移除元素</a></p>
</blockquote>
<h2 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h2>
<p>这题如果直接用Go的切片功能去删除元素会出现问题，因为一遍遍历数组一边修改数组会导致遍历时的索引出现问题，所以我们还是继续用双指针。双指针技术在数组或链表的问题中非常常用，它可以帮助我们以线性时间复杂度解决问题。</p>
<h2 id="解题方法-2"><a class="markdownIt-Anchor" href="#解题方法-2"></a> 解题方法</h2>
<p>创建两个指针，一个用于遍历数组（我们称之为右指针），另一个用于指向下一个将要插入的位置（我们称之为左指针）。<br />
从左到右遍历数组，对于每一个元素，检查它是否等于给定的值。<br />
如果元素不等于给定的值，就把它复制到左指针指向的位置，然后把左指针向右移动一位。<br />
如果元素等于给定的值，就忽略它，不做任何操作。<br />
遍历完数组后，左指针的位置就是新的数组长度。</p>
<h2 id="复杂度-2"><a class="markdownIt-Anchor" href="#复杂度-2"></a> 复杂度</h2>
<p>时间复杂度:<br />
这两段代码都是通过一次遍历完成的，其中 n 是数组的长度。在遍历过程中，每个元素都被访问一次并进行一次比较操作，因此，时间复杂度是 O(n)。</p>
<p>空间复杂度:<br />
这两段代码都是在原地修改数组，没有使用额外的数组或其他数据结构。除了输入数组外，只使用了常数个变量（例如，左指针、右指针和 val）。因此，空间复杂度是 O(1)。</p>
<h2 id="code-2"><a class="markdownIt-Anchor" href="#code-2"></a> Code</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeElement</span><span class="params">(nums []<span class="type">int</span>, val <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    i:=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;<span class="built_in">len</span>(nums);j++&#123;</span><br><span class="line">        <span class="keyword">if</span> nums[j]!=val&#123;</span><br><span class="line">            nums[i]=nums[j]</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="26删除有序数组中的重复项"><a class="markdownIt-Anchor" href="#26删除有序数组中的重复项"></a> 26.删除有序数组中的重复项</h1>
<blockquote>
<p>Problem: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/">26. 删除有序数组中的重复项</a></p>
</blockquote>
<h2 id="思路-3"><a class="markdownIt-Anchor" href="#思路-3"></a> 思路</h2>
<p>代码的主要思想是使用两个指针，一个慢指针 i 和一个快指针 j，同时遍历数组。其中，慢指针指向当前处理的元素，快指针用于寻找下一个不同的元素。</p>
<h2 id="解题方法-3"><a class="markdownIt-Anchor" href="#解题方法-3"></a> 解题方法</h2>
<p>首先检查数组是否为空，如果为空，则直接返回0，因为没有元素需要处理。</p>
<p>初始化两个指针 i 和 j，并设置 i=0。这里，i 是一个慢指针，它表示已处理的不同元素的数量，j 是一个快指针，用于遍历数组寻找下一个不同的元素。</p>
<p>使用一个 for 循环，从 j=1 开始遍历数组。在每次迭代中，检查 nums[j] 是否与 nums[i] 不同。如果 nums[j] 与 nums[i] 不同，这意味着我们找到了一个新的不同的元素。此时，我们将 nums[j] 的值赋给 nums[i+1]，并将 i 的值加1，表示我们找到了一个新的不同的元素。当 for 循环结束时，i+1 的值就是数组中不同元素的数量。因此，我们返回 i+1。</p>
<h2 id="复杂度-3"><a class="markdownIt-Anchor" href="#复杂度-3"></a> 复杂度</h2>
<p>时间复杂度:<br />
时间复杂度是O(n)，因为我们只遍历数组一次。</p>
<p>空间复杂度:<br />
空间复杂度是 O(1)，因为我们只使用了常数个额外的变量。</p>
<h2 id="code-3"><a class="markdownIt-Anchor" href="#code-3"></a> Code</h2>
<figure class="highlight go"><figcaption><span>[]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeDuplicates</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; <span class="built_in">len</span>(nums); j++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[j] != nums[i] &#123;</span><br><span class="line">            i++</span><br><span class="line">            nums[i] = nums[j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="80删除有序数组中的重复项-ii"><a class="markdownIt-Anchor" href="#80删除有序数组中的重复项-ii"></a> 80.删除有序数组中的重复项 II</h1>
<blockquote>
<p>Problem: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/description/">80. 删除有序数组中的重复项 II</a></p>
</blockquote>
<h2 id="思路-4"><a class="markdownIt-Anchor" href="#思路-4"></a> 思路</h2>
<p>这道题目要求我们在一个有序数组中删除重复项，使每个元素最多出现两次，并返回新的数组长度。在不使用额外空间的条件下，我们可以考虑使用双指针的方法来解决这个问题。</p>
<p>注意题给数组为有序数组</p>
<h2 id="解题方法-4"><a class="markdownIt-Anchor" href="#解题方法-4"></a> 解题方法</h2>
<p>我们使用两个指针，一个用于遍历数组（fast），另一个指向当前修改的位置（slow）。</p>
<p>具体步骤如下：</p>
<p>如果数组的长度小于等于2，那么所有的元素都应该保留，因为他们的出现次数都不会超过2次，所以直接返回数组的长度即可。</p>
<p>初始化两个指针，slow = 2 和 fast = 2。slow指针表示处理过的数组的长度，fast指针表示已经检查过的数组的长度。</p>
<p>当 fast &lt; n时，比较 nums[slow - 2] 和 nums[fast]，如果相等，则说明已经有两个数相等，fast指针继续前进。如果不相等，将 nums[fast]的值复制到 nums[slow]，然后增加 slow 和 fast。</p>
<p>返回 slow，表示处理后的数组长度。</p>
<h2 id="复杂度-4"><a class="markdownIt-Anchor" href="#复杂度-4"></a> 复杂度</h2>
<p>时间复杂度: O(n)<br />
这是因为我们只需要遍历一次数组。</p>
<p>空间复杂度: O(1)<br />
我们只使用了常数级别的额外空间。</p>
<h2 id="code-4"><a class="markdownIt-Anchor" href="#code-4"></a> Code</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeDuplicates</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> slow,fast,n=<span class="number">2</span>,<span class="number">2</span>,<span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n&lt;=<span class="number">2</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> fast&lt;n&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[slow<span class="number">-2</span>]!=nums[fast])&#123;</span><br><span class="line">            nums[slow]=nums[fast]</span><br><span class="line">            slow++</span><br><span class="line">        &#125;</span><br><span class="line">        fast++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="169-多数元素"><a class="markdownIt-Anchor" href="#169-多数元素"></a> 169. 多数元素</h1>
<blockquote>
<p>Problem: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/majority-element/description/">169. 多数元素</a></p>
</blockquote>
<h2 id="思路-5"><a class="markdownIt-Anchor" href="#思路-5"></a> 思路</h2>
<p>这道题目要求我们找到一个数组中的多数元素，即出现次数大于数组长度一半的元素。由于题目保证一定存在这样的多数元素，我们可以使用Boyer-Moore投票算法来解决这个问题。</p>
<h2 id="解题方法-5"><a class="markdownIt-Anchor" href="#解题方法-5"></a> 解题方法</h2>
<p>Boyer-Moore投票算法的核心思想是利用“多数元素”的定义，即它的出现次数至少是数组长度的一半。这意味着，如果我们在遍历数组的过程中，对所有非多数元素进行投票（计数），那么当我们遇到多数元素时，计数器应该会增加，直到超过数组长度的一半。在这个过程中，我们只需要维护一个或两个候选多数元素及其计数。</p>
<h3 id="boyer-moore投票算法"><a class="markdownIt-Anchor" href="#boyer-moore投票算法"></a> Boyer-Moore投票算法</h3>
<p>Boyer-Moore 投票算法的步骤如下：</p>
<blockquote>
<p>维护一个候选主要元素 candidate 和候选主要元素的出现次数count。</p>
<p>初始时candidate 为任意值，count=0。</p>
<p>遍历数组nums 中的所有元素，遍历到元素 x 时，进行如下操作：</p>
<p>​       如果count=0，则将 x 的值赋给candidate，否则不更新candidate 的值；</p>
<p>​        如果 x=candidate，则将 count 加 1，否则将count 减 1。</p>
<p>遍历结束之后，candidate的值可能为主要元素。（可能的原因是，如果是这样的一个数组[1,2,3]，那么剩下的元素是3，但是3并不是数量超过一半的元素）</p>
</blockquote>
<p>可以类比为打擂台，candidate就是守擂的多数元素。接着遍历给定数组，如果遇到的同一个类型的数，那么守擂的人数就增加，对应count++；如果遇到的事不同类型的数字，那么守擂方就和打擂台的人同归于尽，对应count–。当count为0时，说明原守擂人已经全部GG了，于是把candidate设置为当前的这个数，作为新的守擂人。</p>
<p>由于一开始不知道谁是势力最大的帮派，所以各个不同帮派之间两两火并。最后剩下来的一定是势力最大的帮派。</p>
<p>就算所有小帮派知道谁是势力最大的帮派，他们“群起攻之”。每一个小帮派的人都消耗掉势力最大的帮派的一个人。但是由于势力最大的帮派的人数大于一半，所以即使这样，最后剩下来的还是大帮派的人。</p>
<p>以上就是Boyer-Moore 投票算法最通俗易懂的解释。</p>
<h2 id="复杂度-5"><a class="markdownIt-Anchor" href="#复杂度-5"></a> 复杂度</h2>
<p>时间复杂度:</p>
<p>O(n)</p>
<p>这个算法只需要遍历数组一次，因此时间复杂度是线性的。</p>
<p>空间复杂度:</p>
<p>O(1)</p>
<p>由于我们只需要一个或两个候选元素和它们的计数器，所以空间复杂度是常数级别的。</p>
<h2 id="code-5"><a class="markdownIt-Anchor" href="#code-5"></a> Code</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">majorityElement</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    candidate:=<span class="number">0</span></span><br><span class="line">    count:=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _,value := <span class="keyword">range</span> nums&#123;</span><br><span class="line">        <span class="keyword">if</span> count==<span class="number">0</span>&#123;</span><br><span class="line">            candidate=value</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> candidate==value&#123;</span><br><span class="line">            count++</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            count--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> candidate</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="189轮转数组"><a class="markdownIt-Anchor" href="#189轮转数组"></a> 189.轮转数组</h1>
<blockquote>
<p>Problem: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-array/description/">189. 轮转数组</a></p>
</blockquote>
<h2 id="思路-6"><a class="markdownIt-Anchor" href="#思路-6"></a> <strong>思路</strong></h2>
<p>当拿到这个问题时，我们的目标是将一个整数数组 nums 向右轮转 k 个位置。这个问题可以通过几种不同的方法解决，但考虑到题目中提到的“原地”算法和空间复杂度为 O(1) 的要求，我们选择一种不需要额外空间的解决方案。</p>
<h2 id="解题方法-6"><a class="markdownIt-Anchor" href="#解题方法-6"></a> 解题方法</h2>
<p>我们选择的解题方法是三次反转法，这种方法简单且满足原地操作的要求。具体步骤如下：</p>
<p>反转整个数组：首先，我们反转整个数组 nums，这样原本在数组末尾的元素就会被移动到数组的开头。</p>
<p>反转前 k 个元素：接下来，我们只反转数组的前 k 个元素。这一步将数组的前 k 个元素放置到正确的位置。</p>
<p>反转剩余的元素：最后，我们反转数组中剩余的部分（从第 k+1 个元素到数组末尾），这样所有的元素都会被放置到正确的位置。</p>
<h2 id="复杂度-6"><a class="markdownIt-Anchor" href="#复杂度-6"></a> 复杂度</h2>
<p>时间复杂度:</p>
<p>O(n)</p>
<p>这个算法需要三次遍历整个数组来完成反转，因此时间复杂度是线性的，与数组的长度成正比。</p>
<p>空间复杂度:</p>
<p>O(1)</p>
<p>由于我们是在原地进行操作，没有使用额外的存储空间，所以空间复杂度是常数级别的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rotate</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    k = k % n <span class="comment">// 防止k大于数组长度</span></span><br><span class="line">    reverse(nums)          <span class="comment">// 先逆序整个数组</span></span><br><span class="line">    reverse(nums[:k])      <span class="comment">// 逆序数组的前k个元素</span></span><br><span class="line">    reverse(nums[k:])      <span class="comment">// 逆序数组的剩余部分</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n/<span class="number">2</span>; i++ &#123;</span><br><span class="line">        nums[i], nums[n<span class="number">-1</span>-i] = nums[n<span class="number">-1</span>-i], nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="121买卖股票的最佳时机"><a class="markdownIt-Anchor" href="#121买卖股票的最佳时机"></a> 121.买卖股票的最佳时机</h1>
<blockquote>
<p>Problem: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">121. 买卖股票的最佳时机</a></p>
</blockquote>
<h2 id="思路-7"><a class="markdownIt-Anchor" href="#思路-7"></a> 思路</h2>
<p>这个问题的关键在于理解股票价格的变化趋势，并找到买入和卖出的最佳时机。由于我们只能进行一次交易，我们需要寻找一个价格的波谷（买入点）和一个紧随其后的价格波峰（卖出点）。</p>
<h2 id="解题方法-7"><a class="markdownIt-Anchor" href="#解题方法-7"></a> 解题方法</h2>
<p>代码采用了一种自底向上的方法来解决这个问题。这种方法的核心思想是从数组的最后一个元素开始向前遍历，动态地更新最大利润。</p>
<ol>
<li>初始化：首先，我们初始化 maxPrice 为数组的最后一个元素，这是我们假设的初始卖出价格。同时，result 初始化为0，这是我们的最大利润。</li>
<li>逆序遍历：然后，我们从倒数第二个元素开始逆序遍历整个数组。</li>
<li>更新最大利润：在每次迭代中，我们计算以当前价格为卖出点的最大利润（maxPrice - prices[i]），并将其与已有的 result 比较，取较大者作为新的最大利润。</li>
<li>更新卖出价格：同时，我们也更新 maxPrice，使其为当前价格和之前 maxPrice 中的较大者。</li>
<li>返回结果：遍历结束后，result 就是我们要找的最大利润。</li>
</ol>
<h2 id="复杂度-7"><a class="markdownIt-Anchor" href="#复杂度-7"></a> 复杂度</h2>
<p>时间复杂度：</p>
<p>O(n)，其中 n 是数组 prices 的长度。这是因为我们只遍历了一次数组。</p>
<p>空间复杂度：</p>
<p>O(1)，我们只使用了两个额外的变量，与输入数组的大小无关。</p>
<h2 id="code-6"><a class="markdownIt-Anchor" href="#code-6"></a> Code</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(prices) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    maxPrice:=prices[<span class="built_in">len</span>(prices)<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">var</span> result <span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="built_in">len</span>(prices)<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--&#123;</span><br><span class="line">        result=max(result,maxPrice-prices[i])</span><br><span class="line">        maxPrice=max(maxPrice,prices[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="122买卖股票的最佳时机-ii"><a class="markdownIt-Anchor" href="#122买卖股票的最佳时机-ii"></a> 122.买卖股票的最佳时机 II</h1>
<blockquote>
<p>Problem: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">122. 买卖股票的最佳时机 II</a></p>
</blockquote>
<h2 id="思路-8"><a class="markdownIt-Anchor" href="#思路-8"></a> 思路</h2>
<p>这个问题是关于股票交易的，目标是找到所有可能的交易对，使得利润最大化。题目要求我们在一个给定的数组中，找到所有可能的交易对，并且每次交易都是买入后卖出，从而获得最大利润。</p>
<h2 id="解题方法-8"><a class="markdownIt-Anchor" href="#解题方法-8"></a> 解题方法</h2>
<p>对于这个问题，我们可以采用一种贪心算法的思想。具体来说，我们可以遍历整个数组，对于每对相邻的天数，如果第二天的价格高于第一天，我们就认为这是一个买入和卖出的机会，从而获得利润。我们将所有这样的利润累加起来，就可以得到最大利润。</p>
<h2 id="复杂度-8"><a class="markdownIt-Anchor" href="#复杂度-8"></a> 复杂度</h2>
<p>时间复杂度:</p>
<p>O(n)</p>
<p>我们只需要遍历一次数组，时间复杂度为线性。</p>
<p>空间复杂度:</p>
<p>O(1)</p>
<p>我们只需要一个变量来存储结果，空间复杂度为常数。</p>
<h2 id="code-7"><a class="markdownIt-Anchor" href="#code-7"></a> Code</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(prices)==<span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> result <span class="type">int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="built_in">len</span>(prices);i++&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices[i]&gt;prices[i<span class="number">-1</span>])&#123;</span><br><span class="line">            result+=prices[i]-prices[i<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="55跳跃游戏"><a class="markdownIt-Anchor" href="#55跳跃游戏"></a> 55.跳跃游戏</h1>
<blockquote>
<p>Problem: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game/description/">55. 跳跃游戏</a></p>
</blockquote>
<h2 id="思路-9"><a class="markdownIt-Anchor" href="#思路-9"></a> 思路</h2>
<p>思路很简单，利用贪心的思想，只要维护一个能到达的最远距离，就能保证当前索引到最远可达距离之间的所有元素都能到达。</p>
<h2 id="解题方法-9"><a class="markdownIt-Anchor" href="#解题方法-9"></a> 解题方法</h2>
<ol>
<li>如果数组长度为1，则直接返回true，因为只有一个位置，无需跳跃。</li>
<li>如果数组的第一个元素为0，返回false，因为无法从起始位置跳到任何地方。<br />
使用一个变量max_step来跟踪当前可以到达的最远索引。</li>
<li>遍历数组，更新max_step为当前可跳跃距离和max_step两者中的最大值</li>
<li>如果当前元素为0且max_step为0且当前索引不是数组的最后一个索引，则返回false，因为这意味着在某个点上无法前进。</li>
<li>每次循环结束时，max_step减1，对应向前进了一格。</li>
</ol>
<h2 id="复杂度-9"><a class="markdownIt-Anchor" href="#复杂度-9"></a> 复杂度</h2>
<p>时间复杂度:</p>
<p>我们只遍历了一遍数组，因此时间复杂度为O(1)</p>
<p>空间复杂度:</p>
<p>我们是就地操作的，除了维护最大可达距离的几个变量外，没有产生额外的空间。故空间复杂度为O(1)</p>
<h2 id="code-8"><a class="markdownIt-Anchor" href="#code-8"></a> Code</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canJump</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">1</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> nums[<span class="number">0</span>]==<span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    max_step:=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i,v := <span class="keyword">range</span> nums&#123;</span><br><span class="line">        max_step=max(max_step,v)</span><br><span class="line">        <span class="keyword">if</span> v==<span class="number">0</span> &amp;&amp; max_step==<span class="number">0</span> &amp;&amp; i!=<span class="built_in">len</span>(nums)<span class="number">-1</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        max_step--</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="45跳跃游戏-ii"><a class="markdownIt-Anchor" href="#45跳跃游戏-ii"></a> 45.跳跃游戏 II</h1>
<blockquote>
<p>Problem: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game-ii/description/">45. 跳跃游戏 II</a></p>
</blockquote>
<h2 id="思路-10"><a class="markdownIt-Anchor" href="#思路-10"></a> 思路</h2>
<p>贪心的思想，确保每次跳的最远，一直往前跳即可。</p>
<h2 id="解题方法-10"><a class="markdownIt-Anchor" href="#解题方法-10"></a> 解题方法</h2>
<p>首先判断如果从改点直接尽力跳能否到达终点？如果能就直接跳并退出循环；如果不能直接到达终点，就寻找如何让自己接下来能够跳的更远：维护一个可以跳跃到达的最远距离，最远距离=该节点的跳跃距离+距离起跳点的距离。每次起跳前都检测自己的跳跃范围内，如何跳才能让自己下一步到达的距离更远。</p>
<h2 id="复杂度-10"><a class="markdownIt-Anchor" href="#复杂度-10"></a> 复杂度</h2>
<p>时间复杂度:</p>
<p>在jump函数中，主循环会持续进行直到step等于len(nums)-1，这意味着主循环会遍历整个数组nums。在循环体内，find_max_step函数被调用，该函数本身也是一个循环，它将遍历从step开始的nums[step]个元素。</p>
<p>因此，jump函数的时间复杂度主要由以下两部分组成：</p>
<p>主循环的时间复杂度：由于step每次增加的值取决于find_max_step函数的返回值，且每次至少增加1，最坏情况下，如果nums中的每个元素都为1，那么step需要增加到len(nums)-1，此时主循环的时间复杂度为O(n)。</p>
<p>find_max_step函数的时间复杂度：在最坏的情况下，这个函数将遍历nums[step]个元素，由于step的值在每次主循环迭代中增加，所以这个函数在整个算法执行过程中的总时间复杂度为O(n^2)。</p>
<p>综合以上两点，整个算法的时间复杂度为O(n^2)。但step的值为n时主函数只需要执行一次，所以实际情况复杂度会比理论上的复杂度更低。</p>
<p>空间复杂度:</p>
<p>在代码中，除了输入数组nums外，没有使用额外的存储空间来存储数据结构。find_max_step函数中的变量max_step和max_id仅用于临时存储，它们的大小不随输入规模n的变化而变化。</p>
<p>因此，空间复杂度为O(1)。</p>
<h2 id="code-9"><a class="markdownIt-Anchor" href="#code-9"></a> Code</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">1</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    step:=<span class="number">0</span></span><br><span class="line">    res:=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> step&lt;<span class="built_in">len</span>(nums)<span class="number">-1</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> step+nums[step]&gt;=<span class="built_in">len</span>(nums)<span class="number">-1</span>&#123;</span><br><span class="line">            res++</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        step=find_max_step(nums,step)</span><br><span class="line">        res++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> step&gt;=<span class="built_in">len</span>(nums)<span class="number">-1</span>&#123;</span><br><span class="line">        res++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">find_max_step</span><span class="params">(nums []<span class="type">int</span>,step <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 寻找最大距离 = 当前节点跳跃距离 + 距离起跳点的距离</span></span><br><span class="line">    max_step:=nums[step]</span><br><span class="line">    max_id:=step</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;=nums[step];i++&#123;</span><br><span class="line">        <span class="keyword">if</span> max_step&lt;nums[step+i]+i&#123;</span><br><span class="line">            max_id=step+i</span><br><span class="line">            max_step=nums[step+i]+i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="274h-指数"><a class="markdownIt-Anchor" href="#274h-指数"></a> 274.H 指数</h1>
<blockquote>
<p>Problem: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/h-index/description/">274. H 指数</a></p>
</blockquote>
<h2 id="思路-11"><a class="markdownIt-Anchor" href="#思路-11"></a> 思路</h2>
<p>这个问题要求我们计算一个研究者的h指数，即至少有h篇论文被引用了h次或以上。解决这个问题的关键在于理解h指数的定义，并找到一种有效的方法来确定满足条件的最小h值。</p>
<h2 id="解题方法-11"><a class="markdownIt-Anchor" href="#解题方法-11"></a> 解题方法</h2>
<ol>
<li>构建额外数组：首先，我们创建一个额外的数组 m，大小为 len(citations) + 1，用来统计引用次数小于或等于每个可能的h值的论文数量。</li>
<li>统计论文数量：遍历 citations 数组，对于每个引用次数 i，我们增加 m[min(len(citations), i)] 的计数，这样 m[j] 就代表了引用次数小于或等于 j 的论文数量。</li>
<li>倒序遍历：然后，我们从 m 数组的末尾开始倒序遍历，累加每个 m[j] 的值到变量 s 中，这个累加值 s 表示引用次数大于或等于 j 的论文数量。</li>
<li>找到h指数：当我们找到第一个满足 s &gt;= j 的 j 时，这个 j 就是研究者的h指数。</li>
</ol>
<h2 id="复杂度-11"><a class="markdownIt-Anchor" href="#复杂度-11"></a> 复杂度</h2>
<p>时间复杂度：</p>
<p>O(n)</p>
<p>我们只需要遍历一次 citations 数组来构建 m 数组，然后再遍历一次 m 数组来找到h指数，因此总的时间复杂度是线性的。</p>
<p>空间复杂度：</p>
<p>O(n)</p>
<p>我们创建了一个大小为 len(citations) + 1 的额外数组 m，因此空间复杂度是线性的。</p>
<h2 id="code-10"><a class="markdownIt-Anchor" href="#code-10"></a> Code</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hIndex</span><span class="params">(citations []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 用一个额外数组m来记录满足引用次数为min(n,citation(i))的论文数</span></span><br><span class="line">    <span class="comment">// 最后倒序遍历m，令s为m[j]的累加和，代表满足引用次数大于j的论文数</span></span><br><span class="line">    <span class="comment">// 当s&gt;=j时，说明至少有满足引用条件的论文数量大于等于引用数</span></span><br><span class="line">    m:=<span class="built_in">make</span>([]<span class="type">int</span>,<span class="built_in">len</span>(citations)+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> _, i:=<span class="keyword">range</span> citations&#123;</span><br><span class="line">        m[min(<span class="built_in">len</span>(citations),i)]++</span><br><span class="line">    &#125;</span><br><span class="line">    s:=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j:=<span class="built_in">len</span>(citations);j&gt;<span class="number">0</span>;j--&#123;</span><br><span class="line">        s+=m[j]</span><br><span class="line">        <span class="keyword">if</span> s&gt;=j&#123;</span><br><span class="line">            <span class="keyword">return</span> j</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="380o1-时间插入-删除和获取随机元素"><a class="markdownIt-Anchor" href="#380o1-时间插入-删除和获取随机元素"></a> 380.O(1) 时间插入、删除和获取随机元素</h1>
<blockquote>
<p>Problem: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-delete-getrandom-o1/description/">380. O(1) 时间插入、删除和获取随机元素</a></p>
</blockquote>
<h2 id="思路-12"><a class="markdownIt-Anchor" href="#思路-12"></a> 思路</h2>
<p>Go本身自带哈希表，用map数据结构去模拟RandomSet类。</p>
<h2 id="解题方法-12"><a class="markdownIt-Anchor" href="#解题方法-12"></a> 解题方法</h2>
<p>一开始的思路是完全用一个map去实现，但是遇到了两个问题：</p>
<ol>
<li>在处理最后一个GetRandom函数时，本来想用map的特性去处理。即为了保证代码安全性，map在用for进行迭代时返回的顺序是随机的。但是由于底层的某些原因，在共有n个且不足8个元素时，第一个元素的概率将是（8-n+1）/8而不是1/n。导致第一个元素出现的概率过大无法通过判题器。具体原因可以参考这篇文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/chillsoul/article/details/123572206">golang Map迭代的随机性</a>。</li>
<li>所以我选择在GetRandom函数中手动创建一个切片，把map的键导出后再用随机数输出。但是每次调用一次GetRandom函数必然需要遍历一次map，因此时间复杂度为O(n)，导致最后提交代码时TE超时了。</li>
</ol>
<p>所以我决定折中一下，在创建类时自带一个切片，用map储存数据-&gt;切片下标的映射，切片储存实际的数据。这样在GetRandom函数中就不需要再遍历map了。</p>
<h2 id="复杂度-12"><a class="markdownIt-Anchor" href="#复杂度-12"></a> 复杂度</h2>
<p>时间复杂度:</p>
<p>map的底层是哈希表，插入和删除操作均为O(1)，故时间复杂度为O(1)</p>
<p>空间复杂度:</p>
<p>RandomSet类创建了和数据等大的map和一个切片，因此占空间复杂度为O(n)。</p>
<h2 id="code-11"><a class="markdownIt-Anchor" href="#code-11"></a> Code</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RandomizedSet <span class="keyword">struct</span> &#123;</span><br><span class="line">    Set <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span></span><br><span class="line">    KeySet []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> RandomizedSet &#123;</span><br><span class="line">        <span class="keyword">return</span> RandomizedSet&#123;</span><br><span class="line">        Set: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>),</span><br><span class="line">        KeySet: <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">0</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *RandomizedSet)</span></span> Insert(val <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    _,ok:=this.Set[val]</span><br><span class="line">    <span class="keyword">if</span> !ok&#123;</span><br><span class="line">        this.Set[val]=<span class="built_in">len</span>(this.KeySet)</span><br><span class="line">        this.KeySet=<span class="built_in">append</span>(this.KeySet,val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *RandomizedSet)</span></span> Remove(val <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    _,ok:=this.Set[val]</span><br><span class="line">    <span class="keyword">if</span> ok&#123;</span><br><span class="line">        id:=this.Set[val] <span class="comment">//待删除元素的下标</span></span><br><span class="line">        last:=<span class="built_in">len</span>(this.KeySet)<span class="number">-1</span> <span class="comment">//最后一个位置</span></span><br><span class="line">        this.KeySet[id]=this.KeySet[last]</span><br><span class="line">        this.Set[this.KeySet[id]]=id</span><br><span class="line">        this.KeySet=this.KeySet[:last]</span><br><span class="line">        <span class="built_in">delete</span>(this.Set,val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *RandomizedSet)</span></span> GetRandom() <span class="type">int</span> &#123;</span><br><span class="line">    randomKey := this.KeySet[rand.Intn(<span class="built_in">len</span>(this.KeySet))]</span><br><span class="line">    <span class="keyword">return</span> randomKey</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RandomizedSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * param_1 := obj.Insert(val);</span></span><br><span class="line"><span class="comment"> * param_2 := obj.Remove(val);</span></span><br><span class="line"><span class="comment"> * param_3 := obj.GetRandom();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h1 id="238除自身以外数组的乘积"><a class="markdownIt-Anchor" href="#238除自身以外数组的乘积"></a> 238.除自身以外数组的乘积</h1>
<blockquote>
<p>Problem: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/product-of-array-except-self/description/">238. 除自身以外数组的乘积</a></p>
</blockquote>
<h2 id="思路-13"><a class="markdownIt-Anchor" href="#思路-13"></a> 思路</h2>
<p>这道题目要求我们计算一个数组中，除了每个元素自身之外，其他所有元素的乘积。题目中明确指出，数组中任意元素的全部前缀元素和后缀元素的乘积都在32位整数范围内，这意味着我们可以使用一个整数来存储这些乘积。</p>
<h2 id="解题方法-13"><a class="markdownIt-Anchor" href="#解题方法-13"></a> 解题方法</h2>
<p>解题的关键在于，我们可以将问题分解为两个部分：计算每个元素左边所有元素的乘积，以及计算每个元素右边所有元素的乘积。然后，将这两个乘积相乘，就可以得到除了当前元素之外的乘积。</p>
<ol>
<li>
<p>初始化：创建一个答案数组ans，其长度与输入数组nums相同，并将ans[0]初始化为1，因为第一个元素左边没有元素。</p>
</li>
<li>
<p>计算左侧乘积：从第二个元素开始，将每个元素与其左侧所有元素的乘积累加到答案数组中。这可以通过一个临时变量tmp来实现，它存储当前元素左侧的乘积。</p>
</li>
<li>
<p>计算右侧乘积：从倒数第二个元素开始，更新答案数组，将每个元素与其右侧所有元素的乘积累加到对应的答案元素上。</p>
</li>
<li>
<p>注意：由于我们不能使用除法，所以我们不能简单地将左侧乘积除以当前元素来得到最终答案。相反，我们需要在计算右侧乘积时，将当前元素的右侧乘积与左侧乘积相乘。<br />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/1717129925-qEDSKo-image.png" alt="image.png" /></p>
</li>
</ol>
<h2 id="复杂度-13"><a class="markdownIt-Anchor" href="#复杂度-13"></a> 复杂度</h2>
<p>时间复杂度:</p>
<p>O(n)，其中n是数组nums的长度。这是因为我们只需要遍历数组两次。</p>
<p>空间复杂度:</p>
<p>O(1)，我们只使用了有限的额外空间（答案数组ans和临时变量tmp），它们的大小不随输入数组的大小而变化。</p>
<h2 id="code-12"><a class="markdownIt-Anchor" href="#code-12"></a> Code</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">productExceptSelf</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    ans[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    tmp:=<span class="number">1</span></span><br><span class="line">    <span class="comment">// 计算下三角</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;n;i++&#123;</span><br><span class="line">        ans[i]=ans[i<span class="number">-1</span>]*nums[i<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算上三角</span></span><br><span class="line">    <span class="keyword">for</span> i:=n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--&#123;</span><br><span class="line">        tmp*=nums[i+<span class="number">1</span>]</span><br><span class="line">        ans[i]*=tmp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="134加油站"><a class="markdownIt-Anchor" href="#134加油站"></a> 134.加油站</h1>
<blockquote>
<p>Problem: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/gas-station/description/">134. 加油站</a></p>
</blockquote>
<h2 id="思路-14"><a class="markdownIt-Anchor" href="#思路-14"></a> 思路</h2>
<p>最简单粗暴的思路就是一个一个遍历加油站，看能否到达。但是需要优化，不然会TE超时。</p>
<h2 id="解题方法-14"><a class="markdownIt-Anchor" href="#解题方法-14"></a> 解题方法</h2>
<p>最开始我的想法是将gas数组和cost数组相减，由于必须要保证启动时汽油充足，所以只需要考虑相减后结果为正数的加油站，再开始遍历。可惜时间复杂度还是太高，最后虽然通过了判题器但是耗时也是最大的那一批擦边过。</p>
<p>另一种简化方法是：经过研究发现，如果从第X个加油站出发，抵达Y加油站后没油了，那么可以证明在X~Y之间的所有加油站，最后都不可能抵达第Y+1个加油站。也就是说，我们在Y加油站瘫痪后，下一次可以直接从Y+1加油站出发，跳过了Y-X中间的所有加油站。经过简化后，耗时大大减短。</p>
<h2 id="复杂度-14"><a class="markdownIt-Anchor" href="#复杂度-14"></a> 复杂度</h2>
<p>时间复杂度:</p>
<p>我们只需要遍历一遍数组，所以时间复杂度为O(N)。</p>
<p>空间复杂度:</p>
<p>没有使用额外空间，故空间复杂度为O(1)。</p>
<h2 id="code-13"><a class="markdownIt-Anchor" href="#code-13"></a> Code</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canCompleteCircuit</span><span class="params">(gas []<span class="type">int</span>, cost []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    length:=<span class="built_in">len</span>(gas)</span><br><span class="line">    <span class="keyword">for</span> start_index:=<span class="number">0</span>;start_index&lt;length;&#123;</span><br><span class="line">        left_gas:=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i:= <span class="number">0</span>;i&lt;length;i++&#123;</span><br><span class="line">            cur_index:=(start_index+i)%length</span><br><span class="line">            left_gas+=gas[cur_index]-cost[cur_index]</span><br><span class="line">            <span class="keyword">if</span> left_gas&lt;<span class="number">0</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> cur_index+<span class="number">1</span>&lt;=start_index&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">                &#125;</span><br><span class="line">                start_index=cur_index+<span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> left_gas&gt;=<span class="number">0</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> start_index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="135分发糖果"><a class="markdownIt-Anchor" href="#135分发糖果"></a> 135.分发糖果</h1>
<blockquote>
<p>Problem: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/candy/description/">135. 分发糖果</a></p>
</blockquote>
<h2 id="思路-15"><a class="markdownIt-Anchor" href="#思路-15"></a> 思路</h2>
<p>这道题目要求给每个孩子分配糖果，满足以下两个条件：</p>
<p>每个孩子至少分配到 1 个糖果。</p>
<p>相邻两个孩子中，评分更高的孩子获得更多的糖果。</p>
<p>为了满足这些条件，我们可以采用双遍历的方法来解决这个问题：</p>
<p>第一次从左到右遍历，保证每个孩子比左边评分低的孩子多。</p>
<p>第二次从右到左遍历，保证每个孩子比右边评分低的孩子多。</p>
<p>通过这样的双向遍历，可以确保每个孩子得到的糖果数量既满足基本条件，又保证了相邻孩子评分高的糖果多。</p>
<h2 id="解题方法-15"><a class="markdownIt-Anchor" href="#解题方法-15"></a> 解题方法</h2>
<p>初始化一个数组 candies，大小与 ratings 相同，初始值都为 1，因为每个孩子至少分配到 1 个糖果。</p>
<p>从左到右遍历 ratings，如果 ratings[i] &gt; ratings[i-1]，那么 candies[i] = candies[i-1] + 1。</p>
<p>从右到左遍历 ratings，如果 ratings[i] &gt; ratings[i+1]，那么 candies[i] = max(candies[i], candies[i+1] + 1)，因为要同时考虑之前从左到右遍历的结果。</p>
<p>最后将 candies 数组中的值加起来就是所需的最少糖果数。</p>
<h2 id="复杂度-15"><a class="markdownIt-Anchor" href="#复杂度-15"></a> 复杂度</h2>
<p>时间复杂度: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
<p>因为我们需要两次遍历 ratings 数组，第一次从左到右，第二次从右到左。</p>
<p>空间复杂度: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
<p>需要一个与 ratings 等长的数组 candies 来存储每个孩子的糖果数。</p>
<h2 id="code-14"><a class="markdownIt-Anchor" href="#code-14"></a> Code</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">candy</span><span class="params">(ratings []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(ratings)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Step 1: Initialize candies array</span></span><br><span class="line">    candies := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> candies &#123;</span><br><span class="line">        candies[i] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Step 2: Traverse from left to right</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> ratings[i] &gt; ratings[i<span class="number">-1</span>] &#123;</span><br><span class="line">            candies[i] = candies[i<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Step 3: Traverse from right to left</span></span><br><span class="line">    <span class="keyword">for</span> i := n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="keyword">if</span> ratings[i] &gt; ratings[i+<span class="number">1</span>] &#123;</span><br><span class="line">            candies[i] = <span class="type">int</span>(math.Max(<span class="type">float64</span>(candies[i]), <span class="type">float64</span>(candies[i+<span class="number">1</span>] + <span class="number">1</span>)))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Step 4: Calculate the total number of candies</span></span><br><span class="line">    totalCandies := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> candies &#123;</span><br><span class="line">        totalCandies += c</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> totalCandies</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="42接雨水"><a class="markdownIt-Anchor" href="#42接雨水"></a> 42.接雨水</h1>
<blockquote>
<p>Problem: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trapping-rain-water/description/">42. 接雨水</a></p>
</blockquote>
<h2 id="思路-16"><a class="markdownIt-Anchor" href="#思路-16"></a> 思路</h2>
<p>思路有二，一种是我自己最开始的设想，一种是GPT给出的思想。</p>
<p>初始代码通过逐层处理每个高度来计算接雨水的格子数。</p>
<p>优化版本使用双指针法。</p>
<h2 id="解题方法-16"><a class="markdownIt-Anchor" href="#解题方法-16"></a> 解题方法</h2>
<h3 id="解法一"><a class="markdownIt-Anchor" href="#解法一"></a> 解法一</h3>
<ol>
<li>
<p>找到最高的柱子：首先遍历整个数组，找到最高的柱子位置 max_i 和高度 max_h。</p>
</li>
<li>
<p>逐层处理：从最高的柱子高度开始，一层一层处理每一层的雨水量，直到所有柱子的高度都变为0。</p>
</li>
<li>
<p>遍历当前数组：每层开始时，重置 left_flag 和 space。</p>
<p>如果 left_flag 还没有设置，并且当前柱子高度不为0，则设置 left_flag 表示遇到了第一个柱子。</p>
<p>如果 left_flag 已经设置，当前柱子高度不为0，并且之前记录了空格数量，则累加雨水量到 ans，重置 space。</p>
<p>如果 left_flag 已经设置，并且当前柱子高度为0，则累加空格数到 space。</p>
<p>如果当前柱子高度不为0，则将当前柱子的高度减1。</p>
<p>重复以上步骤直到最高柱子的高度为0。</p>
</li>
</ol>
<h3 id="解法二"><a class="markdownIt-Anchor" href="#解法二"></a> 解法二</h3>
<ol>
<li>
<p>初始化左右指针：初始化两个指针 left 和 right 分别指向数组的起始位置和结束位置。</p>
</li>
<li>
<p>初始化左右最大高度：初始化 leftMax 和 rightMax 分别为数组起始和结束位置的高度。</p>
</li>
<li>
<p>遍历数组：</p>
<p>比较 height[left] 和 height[right]：</p>
<p>如果 height[left] 较小，则：</p>
<p>如果 height[left] 大于等于 leftMax，则更新 leftMax；</p>
<p>否则，累加 leftMax 与 height[left] 之差到总雨水量 ans；</p>
<p>移动左指针 left 向右一格。</p>
<p>如果 height[right] 较小或相等，则：</p>
<p>如果 height[right] 大于等于 rightMax，则更新 rightMax；</p>
<p>否则，累加 rightMax 与 height[right] 之差到总雨水量 ans；</p>
<p>移动右指针 right 向左一格。</p>
<p>终止条件：当左右指针相遇时，遍历结束。</p>
</li>
</ol>
<h2 id="复杂度-16"><a class="markdownIt-Anchor" href="#复杂度-16"></a> 复杂度</h2>
<p>时间复杂度:</p>
<p>其中原始代码由于每一层都需要遍历整个数组，时间复杂度接近 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>∗</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n*h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span> 是最高柱子的高度。如果数组中存在很高的柱子，遍历次数会非常多。所以我自己的代码遇到了TLE超时错误，通过例320/322，不通过的例子中柱子的高度达到了近十万……</p>
<p>优化版本由于每个元素最多只会被处理一次，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是数组长度。</p>
<p>空间复杂度:</p>
<p>原始代码和优化代码都只是用了常数级的额外空间，故空间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
<h2 id="code-15"><a class="markdownIt-Anchor" href="#code-15"></a> Code</h2>
<h3 id="解法一-2"><a class="markdownIt-Anchor" href="#解法一-2"></a> 解法一</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trap</span><span class="params">(height []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 思路：从第一个非零数字开始，每遇到一个0就可以计一格雨水，一直循环到数组末尾</span></span><br><span class="line">    <span class="comment">// 遍历完底层之后，所有柱子高度减一，高度为0的柱子不变</span></span><br><span class="line">    <span class="comment">// 追踪最高的柱子，当最高的柱子高度为0时意味着统计结束</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    如何计算接到的雨水格子数也有窍门，不能简单的用一个flag去标记，因为电脑分不清墙和数组边界的区别</span></span><br><span class="line"><span class="comment">    所以需要用两个标志变量判断空隙是否两面夹墙</span></span><br><span class="line"><span class="comment">    具体来说，首先用left_flag来标记遇见起始墙</span></span><br><span class="line"><span class="comment">    然后用一个变量统计空格的个数</span></span><br><span class="line"><span class="comment">    如果又遇到了墙，设置right_flag来标记遇见了结束墙</span></span><br><span class="line"><span class="comment">    此时说明空格能够接水，把空格数加入到ans中，然后清零，并复位两个标志变量</span></span><br><span class="line"><span class="comment">    如果只遇到了开始墙却没有遇到结束墙，说明区域开放，丢弃统计的空格数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    max_h:=<span class="number">0</span></span><br><span class="line">    max_i:=<span class="number">0</span></span><br><span class="line">    ans:=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i,v := <span class="keyword">range</span> height&#123;</span><br><span class="line">        <span class="keyword">if</span> max_h&lt;v&#123;</span><br><span class="line">            max_h=v</span><br><span class="line">            max_i=i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> height[max_i]!=<span class="number">0</span>&#123;</span><br><span class="line">        left_flag:=<span class="number">0</span> </span><br><span class="line">        <span class="comment">//right_flag:=0</span></span><br><span class="line">        space:=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i,v := <span class="keyword">range</span> height&#123; <span class="comment">//遍历搜寻0格子</span></span><br><span class="line">        <span class="comment">//判断墙的情况</span></span><br><span class="line">            <span class="keyword">if</span> left_flag==<span class="number">0</span>&amp;&amp;v!=<span class="number">0</span>&#123;</span><br><span class="line">                left_flag=<span class="number">1</span> <span class="comment">//遇到了第一个非0格子</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> left_flag==<span class="number">1</span>&amp;&amp;v!=<span class="number">0</span>&amp;&amp;space!=<span class="number">0</span>&#123; <span class="comment">//如果墙已经开始且遇到了新的墙且先前已经开始计数</span></span><br><span class="line">                ans+=space</span><br><span class="line">                <span class="comment">//left_flag=0</span></span><br><span class="line">                space=<span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//判断空格的情况</span></span><br><span class="line">            <span class="keyword">if</span> left_flag==<span class="number">1</span>&amp;&amp;v==<span class="number">0</span>&#123;</span><br><span class="line">                space++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> v!=<span class="number">0</span>&#123;</span><br><span class="line">                height[i]-- <span class="comment">//离开柱子时将其高度减一</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解法二-2"><a class="markdownIt-Anchor" href="#解法二-2"></a> 解法二</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trap</span><span class="params">(height []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(height) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(height)<span class="number">-1</span></span><br><span class="line">    leftMax, rightMax := height[left], height[right]</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        <span class="keyword">if</span> height[left] &lt; height[right] &#123;</span><br><span class="line">            <span class="keyword">if</span> height[left] &gt;= leftMax &#123;</span><br><span class="line">                leftMax = height[left]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += leftMax - height[left]</span><br><span class="line">            &#125;</span><br><span class="line">            left++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> height[right] &gt;= rightMax &#123;</span><br><span class="line">                rightMax = height[right]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += rightMax - height[right]</span><br><span class="line">            &#125;</span><br><span class="line">            right--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="13罗马数字转整数"><a class="markdownIt-Anchor" href="#13罗马数字转整数"></a> 13.罗马数字转整数</h1>
<blockquote>
<p>Problem: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/roman-to-integer/description/">13. 罗马数字转整数</a></p>
</blockquote>
<h2 id="思路-17"><a class="markdownIt-Anchor" href="#思路-17"></a> 思路</h2>
<p>看到这一题，我们需要将罗马数字字符串转换为整数。罗马数字有一些特定的规则：</p>
<ol>
<li>相同字符的重复表示加法，例如 “III” 表示 3。</li>
<li>小的数字放在大的数字前面表示减法，例如 “IV” 表示 4。</li>
<li>小的数字放在大的数字后面表示加法，例如 “VI” 表示 6。</li>
<li>基于这些规则，我们可以通过遍历字符串来进行转换。</li>
</ol>
<h2 id="解题方法-17"><a class="markdownIt-Anchor" href="#解题方法-17"></a> 解题方法</h2>
<ol>
<li>
<p>建立一个哈希表 dic，将罗马数字字符映射到对应的整数值。</p>
</li>
<li>
<p>初始化一个变量 ans 用于存储最终的结果。</p>
</li>
<li>
<p>遍历字符串 s：</p>
<p>对于每一个字符 s[i]，如果当前字符的值小于下一个字符的值（即 dic[s[i]] &lt; dic[s[i+1]]），则减去当前字符的值，因为这意味着这是一个减法操作。</p>
<p>否则，加上当前字符的值。</p>
<p>最终得到的 ans 就是转换后的整数值。</p>
</li>
</ol>
<h2 id="复杂度-17"><a class="markdownIt-Anchor" href="#复杂度-17"></a> 复杂度</h2>
<p>时间复杂度: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
<p>我们只需要遍历字符串一次，因此时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是字符串的长度。</p>
<p>空间复杂度: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
<p>除了存储映射关系的哈希表外，我们只使用了常数级别的额外空间。</p>
<h2 id="code-16"><a class="markdownIt-Anchor" href="#code-16"></a> Code</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">romanToInt</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 首先建立map哈希表映射字符串</span></span><br><span class="line">    dic := <span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>&#123;</span><br><span class="line">        <span class="string">&#x27;I&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;V&#x27;</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="string">&#x27;X&#x27;</span>: <span class="number">10</span>,</span><br><span class="line">        <span class="string">&#x27;L&#x27;</span>: <span class="number">50</span>,</span><br><span class="line">        <span class="string">&#x27;C&#x27;</span>: <span class="number">100</span>,</span><br><span class="line">        <span class="string">&#x27;D&#x27;</span>: <span class="number">500</span>,</span><br><span class="line">        <span class="string">&#x27;M&#x27;</span>: <span class="number">1000</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对字符串从左到右处理</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="comment">// 如果第i个字符小于第i+1个字符，则减去第i个字符</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; n<span class="number">-1</span> &amp;&amp; dic[s[i]] &lt; dic[s[i+<span class="number">1</span>]] &#123;</span><br><span class="line">            ans -= dic[s[i]]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则，加上第i个字符</span></span><br><span class="line">            ans += dic[s[i]]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="12整数转罗马数字"><a class="markdownIt-Anchor" href="#12整数转罗马数字"></a> 12.整数转罗马数字</h1>
<blockquote>
<p>Problem: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/integer-to-roman/description/">12. 整数转罗马数字</a></p>
</blockquote>
<h2 id="思路-18"><a class="markdownIt-Anchor" href="#思路-18"></a> 思路</h2>
<p>暴力打表，同时运用贪心的算法尽可能的多匹配字符串。</p>
<h2 id="解题方法-18"><a class="markdownIt-Anchor" href="#解题方法-18"></a> 解题方法</h2>
<p>建立起数字映射表，然后从最大的数字开始匹配，并输出转换后的字符串</p>
<h2 id="复杂度-18"><a class="markdownIt-Anchor" href="#复杂度-18"></a> 复杂度</h2>
<p>时间复杂度：</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，因为虽然有循环，但是循环次数是固定的，与输入大小无关。</p>
<p>空间复杂度：</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，只使用了固定大小的额外空间</p>
<h2 id="code-17"><a class="markdownIt-Anchor" href="#code-17"></a> Code</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intToRoman</span><span class="params">(num <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="comment">// 建立罗马数字映射表</span></span><br><span class="line">    val := []<span class="type">int</span>&#123;<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>&#125;</span><br><span class="line">    syms := []<span class="type">string</span>&#123;<span class="string">&quot;M&quot;</span>, <span class="string">&quot;CM&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;XC&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;IX&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;I&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    roman := <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从大到小遍历映射表</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(val); i++ &#123;</span><br><span class="line">        <span class="comment">// 对于每个罗马数字，尽可能多地匹配</span></span><br><span class="line">        <span class="keyword">for</span> num &gt;= val[i] &#123;</span><br><span class="line">            num -= val[i]</span><br><span class="line">            roman += syms[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> roman</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="58最后一个单词的长度"><a class="markdownIt-Anchor" href="#58最后一个单词的长度"></a> 58.最后一个单词的长度</h1>
<blockquote>
<p>Problem: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/length-of-last-word/description/">58. 最后一个单词的长度</a></p>
</blockquote>
<h2 id="思路-19"><a class="markdownIt-Anchor" href="#思路-19"></a> 思路</h2>
<p>直接调包，用strings.Split函数切割字符串，再打印最后一个单词的长度。</p>
<h2 id="解题方法-19"><a class="markdownIt-Anchor" href="#解题方法-19"></a> 解题方法</h2>
<p>用Split分隔后，从最后一项开始寻找非空字符串，然后返回长度。</p>
<h2 id="复杂度-19"><a class="markdownIt-Anchor" href="#复杂度-19"></a> 复杂度</h2>
<p>时间复杂度:</p>
<p>Split函数复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，故时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p>
<p>空间复杂度:</p>
<p>创建了一个原字符串大小的切片，故空间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
<h2 id="code-18"><a class="markdownIt-Anchor" href="#code-18"></a> Code</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;strings&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLastWord</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    slice:=strings.Split(s,<span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i:= <span class="built_in">len</span>(slice)<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--&#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(slice[i])==<span class="number">0</span>&#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(slice[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="comment">//    return len(slice[len(slice)-1])</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="14最长公共前缀"><a class="markdownIt-Anchor" href="#14最长公共前缀"></a> 14.最长公共前缀</h1>
<blockquote>
<p>Problem: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-prefix/description/">14. 最长公共前缀</a></p>
</blockquote>
<h2 id="思路-20"><a class="markdownIt-Anchor" href="#思路-20"></a> 思路</h2>
<p>思路有很多，可以横向搜索，也可以纵向搜索。这里我用的是纵向搜索。</p>
<h2 id="解题方法-20"><a class="markdownIt-Anchor" href="#解题方法-20"></a> 解题方法</h2>
<p>搜索每一个字符串中的第i个字符是否相等，如果不相等或者i等于某个子串的长度，查找结束，返回字符串即最长公共前缀。</p>
<h2 id="复杂度-20"><a class="markdownIt-Anchor" href="#复杂度-20"></a> 复杂度</h2>
<p>时间复杂度:</p>
<p>时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(mn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，m是最长公共前缀的长度，n是字符串的个数。</p>
<p>空间复杂度:</p>
<p>空间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，没有使用额外空间。</p>
<h2 id="code-19"><a class="markdownIt-Anchor" href="#code-19"></a> Code</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestCommonPrefix</span><span class="params">(strs []<span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(strs) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(strs[<span class="number">0</span>]);i++&#123;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;<span class="built_in">len</span>(strs);j++&#123;</span><br><span class="line">            <span class="keyword">if</span> i==<span class="built_in">len</span>(strs[j])||strs[j][i]!=strs[<span class="number">0</span>][i]&#123;</span><br><span class="line">                <span class="keyword">return</span> strs[<span class="number">0</span>][:i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strs[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="151反转字符串中的单词"><a class="markdownIt-Anchor" href="#151反转字符串中的单词"></a> 151.反转字符串中的单词</h1>
<blockquote>
<p>Problem: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-words-in-a-string/description/">151. 反转字符串中的单词</a></p>
</blockquote>
<h2 id="思路-21"><a class="markdownIt-Anchor" href="#思路-21"></a> 思路</h2>
<p>灵活调包，用strings包下的Split和Join函数处理。</p>
<h2 id="解题方法-21"><a class="markdownIt-Anchor" href="#解题方法-21"></a> 解题方法</h2>
<p>首先用Split函数把字符串以空格为间隙切割成字符切片，然后从后往前遍历所有长度不为0的元素，倒序添加进新的切片并加上一个空格。</p>
<p>记住循环结束后要弹出结尾的空格。最后用Join函数合并字符切片转为字符串即可。</p>
<h2 id="复杂度-21"><a class="markdownIt-Anchor" href="#复杂度-21"></a> 复杂度</h2>
<p>时间复杂度:</p>
<p>Split函数的操作时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，故时间复杂度应为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p>
<p>空间复杂度:</p>
<p>创建了一个切片储存倒序字符串，故空间复杂度应为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p>
<h2 id="code-20"><a class="markdownIt-Anchor" href="#code-20"></a> Code</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;strings&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseWords</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    split:=strings.Split(s,<span class="string">&quot; &quot;</span>)</span><br><span class="line">    ans:=<span class="built_in">make</span>([]<span class="type">string</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="built_in">len</span>(split)<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--&#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(split[i])!=<span class="number">0</span>&#123;</span><br><span class="line">            ans=<span class="built_in">append</span>(ans,split[i])</span><br><span class="line">            ans=<span class="built_in">append</span>(ans,<span class="string">&quot; &quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=ans[:<span class="built_in">len</span>(ans)<span class="number">-1</span>] <span class="comment">//弹出最后一个空格</span></span><br><span class="line">    <span class="keyword">return</span> strings.Join(ans,<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="6z字形变换"><a class="markdownIt-Anchor" href="#6z字形变换"></a> 6.Z字形变换</h1>
<blockquote>
<p>Problem: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zigzag-conversion/description/">6. Z 字形变换</a></p>
</blockquote>
<h2 id="思路-22"><a class="markdownIt-Anchor" href="#思路-22"></a> 思路</h2>
<p>这题与其说是Z字形变换，倒不如说是N字形……</p>
<p>可以通过模拟字符串的方式解决，即通过变换规律推导出结果矩阵，依次填充后再输出矩阵为字符串。同时，还可以通过压缩矩阵的方式降低空间复杂度。</p>
<p>但我们还可以通过推导规律直接写出矩阵对应id对应的字符串。</p>
<h2 id="解题方法-22"><a class="markdownIt-Anchor" href="#解题方法-22"></a> 解题方法</h2>
<p>观察矩阵：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0             0+t                    0+2t                     0+3t</span><br><span class="line">1      t-1    1+t            0+2t-1  1+2t            0+3t-1   1+3t</span><br><span class="line">2  t-2        2+t  0+2t-2            2+2t  0+3t-2             2+3t  </span><br><span class="line">3             3+t                    3+2t                     3+3t</span><br></pre></td></tr></table></figure>
<p>设矩阵的字符位置为idx，对应字符串s的位置为i。则不难发现规律：</p>
<ol>
<li>矩阵变换周期为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>2</mn><mo separator="true">⋅</mo><mi>r</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">t=2·r-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></li>
<li>对矩阵第一行，只对应一个元素：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>d</mi><mi>x</mi><mo>≡</mo><mn>0</mn><mtext> </mtext><mo lspace="0.22em" rspace="0.22em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow></mo><mtext> </mtext><mi>t</mi></mrow><annotation encoding="application/x-tex">idx \equiv 0 \bmod t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span></li>
<li>对矩阵最后一行，也只对应一个元素：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>d</mi><mi>x</mi><mo>≡</mo><mi>r</mi><mo>−</mo><mn>1</mn><mtext> </mtext><mo lspace="0.22em" rspace="0.22em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow></mo><mtext> </mtext><mi>t</mi></mrow><annotation encoding="application/x-tex">idx \equiv r-1 \bmod t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span></li>
<li>对其余<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>行，对应两个元素：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>d</mi><mi>x</mi><mo>≡</mo><mi>i</mi><mtext> </mtext><mo lspace="0.22em" rspace="0.22em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow></mo><mtext> </mtext><mi>t</mi></mrow><annotation encoding="application/x-tex">idx \equiv i \bmod t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span>与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>d</mi><mi>x</mi><mo>≡</mo><mi>t</mi><mo>−</mo><mi>i</mi><mtext> </mtext><mo lspace="0.22em" rspace="0.22em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow></mo><mtext> </mtext><mi>t</mi></mrow><annotation encoding="application/x-tex">idx \equiv t-i \bmod t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69841em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span></li>
</ol>
<p>故可直接构造代码。</p>
<h3 id="复杂度-22"><a class="markdownIt-Anchor" href="#复杂度-22"></a> 复杂度</h3>
<p>时间复杂度:</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中n为字符串s的长度。s中的每个字符仅会被访问一次，因此时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p>
<p>空间复杂度:</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，返回值不计入空间复杂度。</p>
<h2 id="code-21"><a class="markdownIt-Anchor" href="#code-21"></a> Code</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convert</span><span class="params">(s <span class="type">string</span>, numRows <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    n,r:=<span class="built_in">len</span>(s),numRows</span><br><span class="line">    <span class="keyword">if</span> r==<span class="number">1</span>||r&gt;=n&#123;</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    &#125;</span><br><span class="line">    t:=<span class="number">2</span>*r<span class="number">-2</span></span><br><span class="line">    ans:=<span class="built_in">make</span>([]<span class="type">byte</span>,<span class="number">0</span>,n)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;r;i++&#123;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>;j+i&lt;n;j+=t&#123;</span><br><span class="line">            ans=<span class="built_in">append</span>(ans,s[i+j])</span><br><span class="line">            <span class="keyword">if</span> i&gt;<span class="number">0</span> &amp;&amp; i&lt;r<span class="number">-1</span> &amp;&amp; t-i+j&lt;n &#123;</span><br><span class="line">                ans=<span class="built_in">append</span>(ans,s[t-i+j])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(ans)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="28找出字符串中第一个匹配项的下标"><a class="markdownIt-Anchor" href="#28找出字符串中第一个匹配项的下标"></a> 28.找出字符串中第一个匹配项的下标</h1>
<blockquote>
<p>Problem: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">28. 找出字符串中第一个匹配项的下标</a></p>
</blockquote>
<h2 id="思路-23"><a class="markdownIt-Anchor" href="#思路-23"></a> 思路</h2>
<p>本来以为是KMP字符串匹配算法，结果是简单题？？？那就直接用内置的语言库秒了。</p>
<p>不过有点恶心的是，我们数据结构和算法设计都没有讲过KMP，我还得自学一遍……也许某天我会专门出一篇讲解KMP算法的博客吧。目前可以参考力扣官方的题解当代餐：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/732236/shi-xian-strstr-by-leetcode-solution-ds6y/?envType=study-plan-v2&amp;envId=top-interview-150">实现 strStr()</a></p>
<h2 id="解题方法-23"><a class="markdownIt-Anchor" href="#解题方法-23"></a> 解题方法</h2>
<p>直接调库strings.Index()函数。</p>
<h2 id="复杂度-23"><a class="markdownIt-Anchor" href="#复杂度-23"></a> 复杂度</h2>
<p>时间复杂度:</p>
<p>Golang中 substr长度大于64/32(视CPU的情况而定)的情况，</p>
<p>查找采用的rabin-karp算法，它是由Richard M. Karp和 Michael O. Rabin在1987年提出的。它的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n + m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>，最坏情况下的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>∗</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n * m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>。</p>
<p>Go的strings.Index()函数底层实现参考文章：<a target="_blank" rel="noopener" href="https://vearne.cc/archives/611">GOLANG STRINGS中的INDEX函数(字符串查找)</a></p>
<p>空间复杂度:</p>
<p>没有使用额外空间，复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
<h2 id="code-22"><a class="markdownIt-Anchor" href="#code-22"></a> Code</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;strings&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">strStr</span><span class="params">(haystack <span class="type">string</span>, needle <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> strings.Index(haystack,needle)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="68文本左右对齐"><a class="markdownIt-Anchor" href="#68文本左右对齐"></a> 68.文本左右对齐</h1>
<blockquote>
<p>&gt; Problem: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/text-justification/description/">68. 文本左右对齐</a></p>
</blockquote>
<h2 id="思路-24"><a class="markdownIt-Anchor" href="#思路-24"></a> 思路</h2>
<p>这道题目是关于文本左右对齐的问题，需要在给定的最大宽度下，将一系列单词进行排版，使得每一行的文本符合左右对齐的要求。关键点在于如何计算和分配每一行的空格，使得文本能够对齐。</p>
<h2 id="解题方法-24"><a class="markdownIt-Anchor" href="#解题方法-24"></a> 解题方法</h2>
<p>这里参照了力扣的官方题解<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/text-justification/solutions/986756/wen-ben-zuo-you-dui-qi-by-leetcode-solut-dyeg/?envType=study-plan-v2&amp;envId=top-interview-150">文本左右对齐</a>，总结出了以下规律：</p>
<blockquote>
<ol>
<li>当前行是最后一行：单词左对齐，且单词之间应只有一个空格，在行末填充剩余空格；</li>
<li>当前行不是最后一行，且只有一个单词：该单词左对齐，在行末填充空格；</li>
<li>当前行不是最后一行，且不只一个单词：设当前行单词数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>W</mi><mi>o</mi><mi>r</mi><mi>d</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">numWords</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">d</span><span class="mord mathnormal">s</span></span></span></span>，空格数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>S</mi><mi>p</mi><mi>a</mi><mi>c</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">numSpaces</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span></span></span></span>，我们需要将空格均匀分配在单词之间，则单词之间至少有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext> avgSpaces </mtext><mo>=</mo><mrow><mo fence="true">⌊</mo><mfrac><mtext> numSpaces </mtext><mrow><mtext> numWords </mtext><mo>−</mo><mn>1</mn></mrow></mfrac><mo fence="true">⌋</mo></mrow></mrow><annotation encoding="application/x-tex">\text { avgSpaces }=\left\lfloor\frac{\text { numSpaces }}{\text { numWords }-1}\right\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord"> avgSpaces </span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.80002em;vertical-align:-0.65002em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">⌊</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.924439em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight"> numWords </span></span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight"> numSpaces </span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">⌋</span></span></span></span></span></span>个空格，应该填在前<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>x</mi><mi>t</mi><mi>r</mi><mi>a</mi><mi>S</mi><mi>p</mi><mi>a</mi><mi>c</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">extraSpaces</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span></span></span></span>个单词之间。因此，前<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>x</mi><mi>t</mi><mi>r</mi><mi>a</mi><mi>S</mi><mi>p</mi><mi>a</mi><mi>c</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">extraSpaces</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span></span></span></span>个单词之间填充<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>v</mi><mi>g</mi><mi>S</mi><mi>p</mi><mi>a</mi><mi>c</mi><mi>e</mi><mi>s</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">avgSpaces+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个空格，其余单词之间应该填充<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>v</mi><mi>g</mi><mi>S</mi><mi>p</mi><mi>a</mi><mi>c</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">avgSpaces</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span></span></span></span>个空格。</li>
</ol>
</blockquote>
<h2 id="复杂度-24"><a class="markdownIt-Anchor" href="#复杂度-24"></a> 复杂度</h2>
<p>时间复杂度:</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>，m是数组words中所有字符串的长度之和。</p>
<p>空间复杂度:</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></p>
<h2 id="code-23"><a class="markdownIt-Anchor" href="#code-23"></a> Code</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fullJustify</span><span class="params">(words []<span class="type">string</span>, maxWidth <span class="type">int</span>)</span></span> (ans []<span class="type">string</span>) &#123;</span><br><span class="line">    right,n:=<span class="number">0</span>,<span class="built_in">len</span>(words)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        left := right <span class="comment">//当前行的第一个单词在word的位置</span></span><br><span class="line">        sumLen:=<span class="number">0</span><span class="comment">//统计这一行的单词长度之和</span></span><br><span class="line">        <span class="comment">//循环确定能放多少单词，单词之间至少有一个空格</span></span><br><span class="line">        <span class="keyword">for</span> right &lt;n &amp;&amp; sumLen+<span class="built_in">len</span>(words[right])+right-left&lt;=maxWidth&#123;</span><br><span class="line">            sumLen+=<span class="built_in">len</span>(words[right])</span><br><span class="line">            right++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前行是最后一行：单词左对齐，且单词之间应只有一个空格，在行末填充剩余空格</span></span><br><span class="line">        <span class="keyword">if</span> right == n &#123;</span><br><span class="line">            s := strings.Join(words[left:], <span class="string">&quot; &quot;</span>)<span class="comment">//填充单词</span></span><br><span class="line">            ans = <span class="built_in">append</span>(ans, s+blank(maxWidth-<span class="built_in">len</span>(s)))<span class="comment">//填充空格</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        numWords:=right-left <span class="comment">// 本行总单词数</span></span><br><span class="line">        numSpace:= maxWidth-sumLen <span class="comment">//本行总空格数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 本行只有一个单词：单词向左对齐，末尾填充空格</span></span><br><span class="line">        <span class="keyword">if</span> numWords==<span class="number">1</span>&#123;</span><br><span class="line">            ans=<span class="built_in">append</span>(ans,words[left]+blank(numSpace))</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前行不止一个单词，先依次填充好单词和中间空格，再把额外的空格填入前extra个单词中间</span></span><br><span class="line">        avgSpaces:= numSpace/(numWords<span class="number">-1</span>)<span class="comment">//填充进每个单词间的正常空格数</span></span><br><span class="line">        extraSpaces:=numSpace%(numWords<span class="number">-1</span>)<span class="comment">//余下的空格数就是多出的空格</span></span><br><span class="line"></span><br><span class="line">        s1:=strings.Join(words[left:left+extraSpaces+<span class="number">1</span>],blank(avgSpaces+<span class="number">1</span>)) <span class="comment">// 额外拼接一个空格</span></span><br><span class="line">        s2:=strings.Join(words[left+extraSpaces+<span class="number">1</span>:right],blank(avgSpaces)) <span class="comment">// 拼接其余单词</span></span><br><span class="line">        ans=<span class="built_in">append</span>(ans,s1+blank(avgSpaces)+s2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">blank</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">string</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> strings.Repeat(<span class="string">&quot; &quot;</span>,n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="125验证回文串"><a class="markdownIt-Anchor" href="#125验证回文串"></a> 125.验证回文串</h1>
<blockquote>
<p>&gt; Problem: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-palindrome/description/">125. 验证回文串</a></p>
</blockquote>
<h2 id="思路-25"><a class="markdownIt-Anchor" href="#思路-25"></a> 思路</h2>
<p>要验证回文串的思路其实很简单，核心就是用双指针进行遍历判断。本题还在原先的基础上添加了空格、符号等字符进行干扰，要求清洗字符串并忽略大小写后再进行判断。要实现这两点的方法很多。</p>
<h2 id="解题方法-25"><a class="markdownIt-Anchor" href="#解题方法-25"></a> 解题方法</h2>
<p>一种方法是简单粗暴的调包，用string包的ToLower()转换字符串为全小写，然后再调用regexp包的Compile()与ReplaceAllString()来进行正则清洗后再进行回文串的判断。但这种方法会产生额外的字符串储存开销，而且正则编译比较耗时。</p>
<p>第二种方法就是直接在原字符串上进行操作，这样做更加省时快捷。</p>
<h2 id="复杂度-25"><a class="markdownIt-Anchor" href="#复杂度-25"></a> 复杂度</h2>
<p>时间复杂度:</p>
<p>方法一：时间复杂度: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
<p>将字符串全部转换为小写：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p>
<p>使用正则表达式删除非字母数字字符：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p>
<p>再次遍历清理后的字符串进行回文检查：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p>
<p>方法二：时间复杂度: O(n)</p>
<p>遍历字符串一次，同时从两端向中间扫描，跳过非字母数字字符。</p>
<p>比较字符时，将小写字母转换为大写字母（如果需要）。</p>
<p>空间复杂度:</p>
<p>方法一：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，使用了额外的字符串存储转换后的结果和清理后的结果。</p>
<p>方法二：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，除了几个变量外，没有使用额外的空间。</p>
<h2 id="code-24"><a class="markdownIt-Anchor" href="#code-24"></a> Code</h2>
<p>方法一：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">    <span class="string">&quot;regexp&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    lowered:=strings.ToLower(s)</span><br><span class="line">    reg,_:=regexp.Compile(<span class="string">&quot;[^a-zA-Z0-9]+&quot;</span>)</span><br><span class="line">    cleaned:=reg.ReplaceAllString(lowered,<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    left,right:=<span class="number">0</span>,<span class="built_in">len</span>(cleaned)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> left&lt;right&#123;</span><br><span class="line">        <span class="keyword">if</span> cleaned[left]!=cleaned[right]&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        left++</span><br><span class="line">        right--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;unicode&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(s)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        <span class="keyword">for</span> left &lt; right &amp;&amp; !unicode.IsLetter(<span class="type">rune</span>(s[left])) &amp;&amp; !unicode.IsDigit(<span class="type">rune</span>(s[left])) &#123;</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> left &lt; right &amp;&amp; !unicode.IsLetter(<span class="type">rune</span>(s[right])) &amp;&amp; !unicode.IsDigit(<span class="type">rune</span>(s[right])) &#123;</span><br><span class="line">            right--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> left &lt; right &#123;</span><br><span class="line">            <span class="keyword">if</span> unicode.ToLower(<span class="type">rune</span>(s[left])) != unicode.ToLower(<span class="type">rune</span>(s[right])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            left++</span><br><span class="line">            right--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="392判断子序列"><a class="markdownIt-Anchor" href="#392判断子序列"></a> 392.判断子序列</h1>
<blockquote>
<p>&gt; Problem: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/is-subsequence/description/">392. 判断子序列</a></p>
</blockquote>
<h2 id="思路-26"><a class="markdownIt-Anchor" href="#思路-26"></a> 思路</h2>
<p>一道比较简单的字符串处理题，用双指针和贪心思想依次遍历即可。</p>
<h2 id="解题方法-26"><a class="markdownIt-Anchor" href="#解题方法-26"></a> 解题方法</h2>
<p>设置两个指针p1、p2，分别指向字符串s、t。假如p2指向的字符和p1指向的相同，那么就同时右移指针；如果不同，就只右移p2指针用于寻找下一个匹配字符。当t被遍历完时说明寻找失败；如果是s先被遍历完则说明寻找成功。</p>
<p>注意，空字符串是任何字符串的子串；当t为空串时，除s也为空串外应直接返回false。</p>
<h2 id="复杂度-26"><a class="markdownIt-Anchor" href="#复杂度-26"></a> 复杂度</h2>
<p>时间复杂度:</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>，m和n分别是s和t字符串的长度。</p>
<p>空间复杂度:</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，没有产生额外的空间。</p>
<h2 id="code-25"><a class="markdownIt-Anchor" href="#code-25"></a> Code</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSubsequence</span><span class="params">(s <span class="type">string</span>, t <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">//双指针做法</span></span><br><span class="line">    <span class="comment">//一个指s，一个指t</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s)==<span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(t)==<span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    p1,p2:=<span class="number">0</span>,<span class="number">0</span> <span class="comment">// s,t</span></span><br><span class="line">    <span class="keyword">for</span> p2!=<span class="built_in">len</span>(t)<span class="number">-1</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> s[p1]==t[p2]&#123;</span><br><span class="line">            p1++</span><br><span class="line">            p2++</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p2++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> p1==<span class="built_in">len</span>(s)<span class="number">-1</span>&amp;&amp;s[p1]==t[p2]&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="167两数之和-ii-输入有序数组"><a class="markdownIt-Anchor" href="#167两数之和-ii-输入有序数组"></a> 167.两数之和 II - 输入有序数组</h1>
<blockquote>
<p>Problem: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/description/">167. 两数之和 II - 输入有序数组</a></p>
</blockquote>
<h2 id="思路-27"><a class="markdownIt-Anchor" href="#思路-27"></a> 思路</h2>
<p>很简单的一道题，已知题目条件数组为非递减有序数组，则用二分查找的思想来寻找两数之和就好。</p>
<h2 id="解题方法-27"><a class="markdownIt-Anchor" href="#解题方法-27"></a> 解题方法</h2>
<p>设置两个指针left和right，分别指向数组两端，并计算两数之和sum。如果sum＜target，则left++；如果sum＞target，则right–；如果sum=target，则返回left+1和right+1的数组即可。</p>
<h2 id="复杂度-27"><a class="markdownIt-Anchor" href="#复杂度-27"></a> 复杂度</h2>
<p>时间复杂度:</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，n为题给数组长度。</p>
<p>空间复杂度:</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，只使用了常数级的额外空间。</p>
<h2 id="code-26"><a class="markdownIt-Anchor" href="#code-26"></a> Code</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(numbers []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">//题目已知序列为非递减有序</span></span><br><span class="line">    <span class="comment">//参考快排的方法从两边开始累加</span></span><br><span class="line">    left,right:=<span class="number">0</span>,<span class="built_in">len</span>(numbers)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> left&lt;right&#123;</span><br><span class="line">        sum:=numbers[left]+numbers[right]</span><br><span class="line">        <span class="keyword">if</span> sum==target&#123;</span><br><span class="line">            <span class="keyword">return</span> []<span class="type">int</span>&#123;left+<span class="number">1</span>,right+<span class="number">1</span>&#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> sum&gt;target&#123;</span><br><span class="line">            right--</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> []<span class="type">int</span>&#123;left+<span class="number">1</span>,right+<span class="number">1</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="11盛最多水的容器"><a class="markdownIt-Anchor" href="#11盛最多水的容器"></a> 11.盛最多水的容器</h1>
<blockquote>
<p>Problem: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/container-with-most-water/description/">11. 盛最多水的容器</a></p>
</blockquote>
<h2 id="思路-28"><a class="markdownIt-Anchor" href="#思路-28"></a> 思路</h2>
<p>要求接最多的雨水，如果我们选择遍历所有情况，那么时间复杂度将为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，所以我们选择用双指针的做法，将时间复杂度优化到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。</p>
<p>和接雨水思路类似，往往这种需要根据数组元素求最值的题目用双指针会大大简便计算。</p>
<h2 id="解题方法-28"><a class="markdownIt-Anchor" href="#解题方法-28"></a> 解题方法</h2>
<p>设置两个指针分别指向高度数组的两端，计算体积并更新最大值。每次计算完后，移动指向高度较矮边的指针，直到两个指针相遇为止结束。</p>
<h2 id="复杂度-28"><a class="markdownIt-Anchor" href="#复杂度-28"></a> 复杂度</h2>
<p>时间复杂度:</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，因为只遍历了一遍数组。</p>
<p>空间复杂度:</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，只使用了常量级别的额外空间。</p>
<h2 id="code-27"><a class="markdownIt-Anchor" href="#code-27"></a> Code</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxArea</span><span class="params">(height []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    left,right:=<span class="number">0</span>,<span class="built_in">len</span>(height)<span class="number">-1</span></span><br><span class="line">    maxWater:=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> left&lt;right&#123;</span><br><span class="line">        water:=calculateWater(height[left],height[right],right-left)</span><br><span class="line">        <span class="keyword">if</span> water&gt;maxWater&#123;</span><br><span class="line">            maxWater=water</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> height[left]&gt;height[right]&#123;</span><br><span class="line">            right--</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxWater</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculateWater</span><span class="params">(a <span class="type">int</span>,b <span class="type">int</span>,h <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    c:=min(a,b)</span><br><span class="line">    <span class="keyword">return</span> c*h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="15三数之和"><a class="markdownIt-Anchor" href="#15三数之和"></a> 15.三数之和</h1>
<blockquote>
<p>&gt; Problem: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/description/">15. 三数之和</a></p>
</blockquote>
<h2 id="思路-29"><a class="markdownIt-Anchor" href="#思路-29"></a> 思路</h2>
<p>一道非常经典的面试题，相比于基本的两数之和，题目考察的是无序数组的三数之和。我们可以先固定一个元素，这样我们就只需要移动两个元素了，自然而然就会想到用双指针。由于数组无序，所以我们需要先对数组预处理进行排序，然后再调用双指针进行后续处理。</p>
<h2 id="解题方法-29"><a class="markdownIt-Anchor" href="#解题方法-29"></a> 解题方法</h2>
<p>在对数组进行排序后，创建三个指针i，left，right。其中i初始指向数组最左端元素用于遍历每个固定的数组元素。left和right应该位于i+1和n-1的位置，接着移动指针求和直到满足条件为止。</p>
<p>注意的是，题目要求结果不能有重复，所以需要加入一些判断条件来去重。</p>
<h2 id="复杂度-29"><a class="markdownIt-Anchor" href="#复杂度-29"></a> 复杂度</h2>
<p>时间复杂度:</p>
<p>外层循环时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，内层循环时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，故总时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p>
<p>空间复杂度:</p>
<p>额外的排序的空间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，故空间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。</p>
<h2 id="code-28"><a class="markdownIt-Anchor" href="#code-28"></a> Code</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sort&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    ans:=<span class="built_in">make</span>([][]<span class="type">int</span>,<span class="number">0</span>)</span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    n:=<span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;n;i++&#123;</span><br><span class="line">        <span class="keyword">if</span> i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i<span class="number">-1</span>]&#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        left,right:=i+<span class="number">1</span>,n<span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> left&lt;right&#123;</span><br><span class="line">            sum:=nums[i]+nums[left]+nums[right]</span><br><span class="line">            <span class="keyword">if</span> sum&gt;<span class="number">0</span>&#123;</span><br><span class="line">                right--</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> sum &lt;<span class="number">0</span>&#123;</span><br><span class="line">                left++</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans=<span class="built_in">append</span>(ans,[]<span class="type">int</span>&#123;nums[i],nums[left],nums[right]&#125;)</span><br><span class="line">                <span class="keyword">for</span> left&lt;right&amp;&amp;nums[left]==nums[left+<span class="number">1</span>]&#123;</span><br><span class="line">                    left++</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> right&gt;left&amp;&amp;nums[right]==nums[right<span class="number">-1</span>]&#123;</span><br><span class="line">                    right--</span><br><span class="line">                &#125;</span><br><span class="line">                left++</span><br><span class="line">                right--</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="209长度最小的子数组"><a class="markdownIt-Anchor" href="#209长度最小的子数组"></a> 209.长度最小的子数组</h1>
<blockquote>
<p>Problem: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">209. 长度最小的子数组</a></p>
</blockquote>
<h2 id="思路-30"><a class="markdownIt-Anchor" href="#思路-30"></a> 思路</h2>
<p>这道题目要求找到长度最小的连续子数组，使得其元素之和大于等于给定的整数 s。由于子数组的元素必须是连续的，暴力解法（检查所有可能的子数组）虽然可以解决问题，但时间复杂度过高。考虑到这一点，使用滑动窗口的方法是更为合适的选择。</p>
<h2 id="解题过程"><a class="markdownIt-Anchor" href="#解题过程"></a> 解题过程</h2>
<p>滑动窗口的思路是将子数组的边界设为两个指针 start 和 end，初始时都指向数组的起始位置。我们不断地向右移动 end 指针来扩大窗口的大小，直到窗口内的子数组的和 sum 大于等于 s，此时记录当前子数组的长度并尝试通过移动 start 指针来缩小窗口，找到更小的满足条件的子数组。</p>
<h2 id="复杂度-30"><a class="markdownIt-Anchor" href="#复杂度-30"></a> 复杂度</h2>
<p>时间复杂度: O(n)，其中 n 为数组的长度。start 和 end 指针各自最多移动 n 次，因此整体时间复杂度为线性。</p>
<p>空间复杂度: O(1)。我们只使用了固定大小的额外空间，空间复杂度为常数。</p>
<h2 id="code-29"><a class="markdownIt-Anchor" href="#code-29"></a> Code</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minSubArrayLen</span><span class="params">(s <span class="type">int</span>, nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n:=<span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    ans:=math.MaxInt32</span><br><span class="line">    start,end:=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    sum:=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> end&lt;n&#123;</span><br><span class="line">        sum+=nums[end]</span><br><span class="line">        <span class="keyword">for</span> sum&gt;=s&#123;</span><br><span class="line">            ans = min(ans,end-start+<span class="number">1</span>)</span><br><span class="line">            sum-=nums[start]</span><br><span class="line">            start++</span><br><span class="line">        &#125;</span><br><span class="line">        end++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ans == math.MaxInt32&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3无重复字符的最长子串"><a class="markdownIt-Anchor" href="#3无重复字符的最长子串"></a> 3.无重复字符的最长子串</h1>
<blockquote>
<p>Problem: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">3. 无重复字符的最长子串</a></p>
</blockquote>
<h2 id="思路-31"><a class="markdownIt-Anchor" href="#思路-31"></a> 思路</h2>
<p>用滑动窗口来跟踪当前正在检查的子串，并使用哈希表来存储当前窗口中每个字符的位置。如果遇到重复字符，就缩小窗口的左边界，从而移除重复的字符。</p>
<h2 id="解题过程-2"><a class="markdownIt-Anchor" href="#解题过程-2"></a> 解题过程</h2>
<p>创建一个哈希表，键名为字符，键值为整数代表该字符是否存在。从字符串最左边开始往右遍历并维护不重复字符子串长度，如果发现重复字符就把窗口向右移动，直接从右边界开始重新搜寻。</p>
<h2 id="复杂度-31"><a class="markdownIt-Anchor" href="#复杂度-31"></a> 复杂度</h2>
<p>时间复杂度: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 n 是字符串的长度。end 指针在最坏情况下会遍历字符串中的每个字符一次，start 也最多会遍历每个字符一次，所以整体时间复杂度为线性。</p>
<p>空间复杂度: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(min(m, n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，其中 m 是字符集的大小，n 是字符串的长度。哈希表存储的字符数量最多是 m，但在极端情况下可能会存储整个字符串的字符，因此空间复杂度为 O(min(m, n))。</p>
<h2 id="code-30"><a class="markdownIt-Anchor" href="#code-30"></a> Code</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    charIndexMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>)</span><br><span class="line">    maxLen := <span class="number">0</span></span><br><span class="line">    start := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> end := <span class="number">0</span>; end &lt; <span class="built_in">len</span>(s); end++ &#123;</span><br><span class="line">        <span class="keyword">if</span> index, found := charIndexMap[s[end]]; found &amp;&amp; index &gt;= start &#123;</span><br><span class="line">            start = index + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        charIndexMap[s[end]] = end</span><br><span class="line">        maxLen = max(maxLen, end - start + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxLen</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="30串联所有单词的子串"><a class="markdownIt-Anchor" href="#30串联所有单词的子串"></a> 30.串联所有单词的子串</h1>
<blockquote>
<p>Problem: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/substring-with-concatenation-of-all-words/description/">30. 串联所有单词的子串</a></p>
</blockquote>
<h2 id="思路-32"><a class="markdownIt-Anchor" href="#思路-32"></a> 思路</h2>
<p>这道题要求我们在字符串 s 中找到所有的串联子串的起始位置。每个串联子串必须包含 words 数组中的所有字符串，并且这些字符串可以以任意顺序排列连接。要解决这个问题，我们可以采用滑动窗口和哈希表的组合策略，逐步扫描字符串 s，并检查是否存在符合条件的子串。</p>
<h2 id="解题过程-3"><a class="markdownIt-Anchor" href="#解题过程-3"></a> 解题过程</h2>
<p>假设 words 数组中的每个字符串长度为 wordLen，words 的总长度为 totalLen = len(words) * wordLen。</p>
<p>我们需要在字符串 s 中找到所有长度为 totalLen 的子串，并检查这些子串是否由 words 数组中的所有字符串拼接而成。</p>
<p>由于子串的长度是固定的 totalLen，我们可以在 s 中以 wordLen 为步长移动窗口，逐步检查窗口内的子串是否符合要求。</p>
<p>将字符串 s 分成多个长度为 wordLen 的段落，每次检查段落是否在 words 数组中。如果找到符合条件的子串，就记录其起始位置。</p>
<p>使用两个哈希表：一个记录 words 中每个字符串出现的频率，另一个记录当前窗口中每个字符串出现的频率。</p>
<p>当两个哈希表相等时，说明当前窗口内的子串是 words 的一个排列。</p>
<h2 id="复杂度-32"><a class="markdownIt-Anchor" href="#复杂度-32"></a> 复杂度</h2>
<p>- 时间复杂度: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>t</mi><mi>o</mi><mi>t</mi><mi>a</mi><mi>l</mi><mi>L</mi><mi>e</mi><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mtext>wordLen</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O((n - totalLen + 1) \times \text{wordLen})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">L</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">wordLen</span></span><span class="mclose">)</span></span></span></span>，其中 n 是字符串 s 的长度。我们以 wordLen 为步长，遍历字符串，并在每一步比较哈希表的内容，因此时间复杂度近似为线性的。</p>
<p>- 空间复杂度: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mtext>numWords</mtext><mo>×</mo><mtext>wordLen</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\text{numWords} \times \text{wordLen})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord text"><span class="mord">numWords</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">wordLen</span></span><span class="mclose">)</span></span></span></span>，我们使用的哈希表最多需要存储 words 中所有字符串的计数。</p>
<h2 id="code-31"><a class="markdownIt-Anchor" href="#code-31"></a> Code</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findSubstring</span><span class="params">(s <span class="type">string</span>, words []<span class="type">string</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> || <span class="built_in">len</span>(words) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wordLen := <span class="built_in">len</span>(words[<span class="number">0</span>])<span class="comment">//单个单词的长度</span></span><br><span class="line">    totalLen := wordLen * <span class="built_in">len</span>(words)<span class="comment">//给定words词组的总长度</span></span><br><span class="line">    wordCount := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)<span class="comment">//记录words词组中的word及其频数</span></span><br><span class="line">    result := []<span class="type">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, word := <span class="keyword">range</span> words &#123;</span><br><span class="line">        wordCount[word]++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; wordLen; i++ &#123;</span><br><span class="line">        left := i</span><br><span class="line">        right := i</span><br><span class="line">        currentCount := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)<span class="comment">//记录滑动窗口中的word及其频数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> right+wordLen &lt;= <span class="built_in">len</span>(s) &#123;</span><br><span class="line">            word := s[right:right+wordLen]</span><br><span class="line">            right += wordLen</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> _, ok := wordCount[word]; ok &#123;</span><br><span class="line">                currentCount[word]++</span><br><span class="line">                <span class="keyword">for</span> currentCount[word] &gt; wordCount[word] &#123;</span><br><span class="line">                    leftWord := s[left:left+wordLen]</span><br><span class="line">                    currentCount[leftWord]--</span><br><span class="line">                    left += wordLen</span><br><span class="line">                &#125;<span class="comment">//如果单词频数过高，则缩小滑动窗口直到符合频数为止</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> right-left == totalLen &#123;</span><br><span class="line">                    result = <span class="built_in">append</span>(result, left)</span><br><span class="line">                &#125;<span class="comment">//如果滑动窗口符合条件且长度相等，则是一个有效子串</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                currentCount = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">                left = right</span><br><span class="line">            &#125;<span class="comment">//如果窗口内的单词不匹配，该子串无效，清空currentCount哈希表，将left直接置于right，跳过这个窗口直接搜寻下一个</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="76最小覆盖子串"><a class="markdownIt-Anchor" href="#76最小覆盖子串"></a> 76.最小覆盖子串</h1>
<blockquote>
<p>Problem: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-window-substring/description/">76. 最小覆盖子串</a></p>
</blockquote>
<h2 id="思路-33"><a class="markdownIt-Anchor" href="#思路-33"></a> 思路</h2>
<p>典型的滑动窗口问题，要求我们在字符串 s 中找到最小的子串，使得这个子串包含字符串 t 中的所有字符。</p>
<p>我们用两个指针 left 和 right 表示一个滑动窗口，初始时都指向字符串 s 的起始位置。随着 right 指针的移动，我们扩展窗口的右边界，将字符逐个加入窗口。当窗口内包含了字符串 t 的所有字符（包括重复字符），我们可以尝试缩小窗口（即移动 left 指针），以找到更小的子串。在每次找到符合条件的子串后，记录其长度，并与之前找到的最小子串长度进行比较，保留更小的子串。</p>
<p>一个哈希表 targetCount 用来存储字符串 t 中每个字符的频率。另一个哈希表 windowCount 用来存储当前滑动窗口中每个字符的频率。我们通过比较 windowCount 和 targetCount 来判断窗口是否包含了 t 中的所有字符。</p>
<p>扩展窗口：将 right 指针指向的字符加入 windowCount，然后向右移动 right 指针。</p>
<p>收缩窗口：当窗口包含了 t 中的所有字符时，尝试移动 left 指针缩小窗口，直到窗口不再包含 t 的所有字符为止。</p>
<h2 id="解题过程-4"><a class="markdownIt-Anchor" href="#解题过程-4"></a> 解题过程</h2>
<p>初始化：</p>
<p>使用 targetCount 记录字符串 t 中的每个字符及其出现次数。</p>
<p>初始化两个指针 left 和 right，right 从头开始遍历字符串 s。</p>
<p>变量 minLen 用来记录当前找到的最小子串的长度，minStart 用来记录这个子串的起始位置。</p>
<p>滑动窗口遍历：</p>
<p>随着 right 指针的移动，将字符加入 windowCount，并检查窗口是否包含了 t 中的所有字符。</p>
<p>如果当前窗口包含了 t 的所有字符，记录当前窗口的长度，并尝试缩小窗口，即移动 left 指针。</p>
<p>更新最小子串：</p>
<p>每次找到符合条件的窗口时，比较其长度与 minLen，如果更小，则更新 minLen 和 minStart。</p>
<p>最终结果：</p>
<p>如果 minLen 没有被更新过，说明不存在满足条件的子串，返回空字符串 “”。</p>
<p>否则，返回 s 中从 minStart 开始、长度为 minLen 的子串。</p>
<h2 id="复杂度-33"><a class="markdownIt-Anchor" href="#复杂度-33"></a> 复杂度</h2>
<p>- 时间复杂度: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m + n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 m 是字符串 s 的长度，n 是字符串 t 的长度。每个字符在滑动窗口内最多进出一次，因此整个算法的时间复杂度是线性的。</p>
<p>- 空间复杂度: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>（因为英文字母的数量是固定的，为 26 个），哈希表的大小不会超过 26 个字符。</p>
<h2 id="code-32"><a class="markdownIt-Anchor" href="#code-32"></a> Code</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minWindow</span><span class="params">(s <span class="type">string</span>, t <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s)==<span class="number">0</span>||<span class="built_in">len</span>(t)==<span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    targetCount:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(t);i++&#123;</span><br><span class="line">        targetCount[t[i]]++</span><br><span class="line">    &#125;<span class="comment">//统计t中各个字符的出现频数</span></span><br><span class="line"></span><br><span class="line">    windowCount:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>)</span><br><span class="line">    left,right:=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    minLen:=<span class="built_in">len</span>(s)+<span class="number">1</span><span class="comment">//随便一个不可能的数字</span></span><br><span class="line">    minStart:=<span class="number">0</span></span><br><span class="line">    required:=<span class="built_in">len</span>(targetCount)<span class="comment">//t中需要被匹配的字符数量</span></span><br><span class="line">    formed:=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> right&lt;<span class="built_in">len</span>(s)&#123;</span><br><span class="line">        char:=s[right]</span><br><span class="line">        windowCount[char]++</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> targetCount[char]&gt;<span class="number">0</span> &amp;&amp; targetCount[char]==windowCount[char]&#123;</span><br><span class="line">            formed++</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> left&lt;=right &amp;&amp; formed==required&#123;</span><br><span class="line">            char=s[left]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> right-left+<span class="number">1</span>&lt;minLen&#123;</span><br><span class="line">                minLen=right-left+<span class="number">1</span></span><br><span class="line">                minStart=left</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            windowCount[char]--</span><br><span class="line">            <span class="keyword">if</span> targetCount[char]&gt;<span class="number">0</span> &amp;&amp; targetCount[char]&gt;windowCount[char]&#123;</span><br><span class="line">                formed--</span><br><span class="line">            &#125;</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">        right++</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> minLen==<span class="built_in">len</span>(s)+<span class="number">1</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s[minStart:minStart+minLen]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="36有效的数独"><a class="markdownIt-Anchor" href="#36有效的数独"></a> 36.有效的数独</h1>
<blockquote>
<p>Problem: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-sudoku/description/">36. 有效的数独</a></p>
</blockquote>
<h2 id="思路-34"><a class="markdownIt-Anchor" href="#思路-34"></a> 思路</h2>
<p>根据题给要求检查数独即可，分别按照行、列、小九宫格来依次检查。</p>
<h2 id="解题过程-5"><a class="markdownIt-Anchor" href="#解题过程-5"></a> 解题过程</h2>
<p>创建两个二维数组rows和columns，一个三维数组subboxes，用来储存九宫格在对应位置上的数字出现次数。遍历一遍数组，注意到九宫格中的位置i、j，分别对应rows[i]，columns[j]，subboxes[i/3][j/3]。于是只要扫描到一个数字，就将三个表格的index分别+1，index=board[i][j]-1</p>
<h2 id="复杂度-34"><a class="markdownIt-Anchor" href="#复杂度-34"></a> 复杂度</h2>
<p>- 时间复杂度: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
<p>- 空间复杂度: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
<h2 id="code-33"><a class="markdownIt-Anchor" href="#code-33"></a> Code</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidSudoku</span><span class="params">(board [][]<span class="type">byte</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> rows,columns [<span class="number">9</span>][<span class="number">9</span>]<span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> subboxes [<span class="number">3</span>][<span class="number">3</span>][<span class="number">9</span>]<span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> i,row:=<span class="keyword">range</span> board&#123;</span><br><span class="line">        <span class="keyword">for</span> j,column:=<span class="keyword">range</span> row&#123;</span><br><span class="line">            <span class="keyword">if</span> column==<span class="string">&#x27;.&#x27;</span>&#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                index:=column-<span class="string">&#x27;0&#x27;</span><span class="number">-1</span></span><br><span class="line">                rows[i][index]++</span><br><span class="line">                columns[j][index]++</span><br><span class="line">                subboxes[i/<span class="number">3</span>][j/<span class="number">3</span>][index]++</span><br><span class="line">                <span class="keyword">if</span> rows[i][index]&gt;<span class="number">1</span>||columns[j][index]&gt;<span class="number">1</span>||subboxes[i/<span class="number">3</span>][j/<span class="number">3</span>][index]&gt;<span class="number">1</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="54螺旋矩阵"><a class="markdownIt-Anchor" href="#54螺旋矩阵"></a> 54.螺旋矩阵</h1>
<blockquote>
<p>Problem: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix/description/">54. 螺旋矩阵</a></p>
</blockquote>
<h2 id="思路-35"><a class="markdownIt-Anchor" href="#思路-35"></a> 思路</h2>
<p>题目要求按照顺时针螺旋顺序返回矩阵中的所有元素。我们可以通过设置四个边界（上、下、左、右）来控制遍历方向，并不断缩小边界范围，直到遍历完所有元素。</p>
<p>这种方法属于模拟法，即通过人为模拟出遍历矩阵的顺序，依次遍历边界并将其缩小，直至不再有元素可遍历。</p>
<h2 id="解题过程-6"><a class="markdownIt-Anchor" href="#解题过程-6"></a> 解题过程</h2>
<p>每次遍历按以下顺序进行：</p>
<p>从左到右遍历当前上边界，并将上边界向下移动。</p>
<p>从上到下遍历当前右边界，并将右边界向左移动。</p>
<p>从右到左遍历当前下边界，并将下边界向上移动。</p>
<p>从下到上遍历当前左边界，并将左边界向右移动。</p>
<p>当四个边界交叉时，说明已经没有未遍历的元素，结束循环。</p>
<h2 id="复杂度-35"><a class="markdownIt-Anchor" href="#复杂度-35"></a> 复杂度</h2>
<p>- <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 是矩阵的行数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是矩阵的列数。我们需要遍历矩阵中的每个元素，所以时间复杂度与矩阵中的元素数量成正比。</p>
<p>- <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>（不考虑返回结果的空间），只使用了固定数量的额外变量。</p>
<h2 id="code-34"><a class="markdownIt-Anchor" href="#code-34"></a> Code</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spiralOrder</span><span class="params">(matrix [][]<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    r, d := <span class="built_in">len</span>(matrix[<span class="number">0</span>])<span class="number">-1</span>, <span class="built_in">len</span>(matrix)<span class="number">-1</span>  <span class="comment">// 右边界和下边界</span></span><br><span class="line">    l, u := <span class="number">0</span>, <span class="number">0</span>                             <span class="comment">// 左边界和上边界</span></span><br><span class="line">    result := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> l &lt;= r &amp;&amp; u &lt;= d &#123;</span><br><span class="line">        <span class="comment">// 从左到右</span></span><br><span class="line">        <span class="keyword">for</span> i := l; i &lt;= r; i++ &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, matrix[u][i])</span><br><span class="line">        &#125;</span><br><span class="line">        u++</span><br><span class="line">        <span class="keyword">if</span> u &gt; d &#123;  <span class="comment">// 检查上边界是否越界</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从上到下</span></span><br><span class="line">        <span class="keyword">for</span> i := u; i &lt;= d; i++ &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, matrix[i][r])</span><br><span class="line">        &#125;</span><br><span class="line">        r--</span><br><span class="line">        <span class="keyword">if</span> r &lt; l &#123;  <span class="comment">// 检查右边界是否越界</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从右到左</span></span><br><span class="line">        <span class="keyword">for</span> i := r; i &gt;= l; i-- &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, matrix[d][i])</span><br><span class="line">        &#125;</span><br><span class="line">        d--</span><br><span class="line">        <span class="keyword">if</span> d &lt; u &#123;  <span class="comment">// 检查下边界是否越界</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从下到上</span></span><br><span class="line">        <span class="keyword">for</span> i := d; i &gt;= u; i-- &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, matrix[i][l])</span><br><span class="line">        &#125;</span><br><span class="line">        l++</span><br><span class="line">        <span class="keyword">if</span> l &gt; r &#123;  <span class="comment">// 检查左边界是否越界</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/%7B930EB68A-6F85-4666-BA42-9333A5074315%7D.png" alt="{930EB68A-6F85-4666-BA42-9333A5074315}" /></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Adam Ben</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/posts/1f3d16f9a7e2/">http://example.com/posts/1f3d16f9a7e2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Adam8enの8log</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Go/">Go</a><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post_share"><div class="social-share" data-image="https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/%7B930EB68A-6F85-4666-BA42-9333A5074315%7D.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/f4533fd3ef81/" title="Go修炼手册——复合数据类型"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/f5c4c658c9623ef310f3d678caabff4c.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Go修炼手册——复合数据类型</div></div></a></div><div class="next-post pull-right"><a href="/posts/2472bb8ab8a7/" title="4月总结·2024"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/033b910066680a5312d1b433806e879a.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">4月总结·2024</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/4cefd0c437e2/" title="Go修炼手册——函数"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/CE22E4EE388D674AB24D5CE15D445580.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-16</div><div class="title">Go修炼手册——函数</div></div></a></div><div><a href="/posts/aff86bf46351/" title="Go修炼手册——基础数据类型"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/a7a21eb76137fbe20b311c8a2c3ce9bc.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-27</div><div class="title">Go修炼手册——基础数据类型</div></div></a></div><div><a href="/posts/f4533fd3ef81/" title="Go修炼手册——复合数据类型"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/f5c4c658c9623ef310f3d678caabff4c.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-09</div><div class="title">Go修炼手册——复合数据类型</div></div></a></div><div><a href="/posts/87481f6e6c8c/" title="Go修炼手册——方法"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/2c28c545aca49c9b356d3b8ae2f935cf.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-26</div><div class="title">Go修炼手册——方法</div></div></a></div><div><a href="/posts/a280ef22aa55/" title="Go修炼手册——程序结构"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/1c3f280e740cecf4e83406e672b3525e.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-25</div><div class="title">Go修炼手册——程序结构</div></div></a></div><div><a href="/posts/7a99acb03ff0/" title="番外：Go接口的设计哲学"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/d367a38091cb770dfa360d3dbf289740.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-09</div><div class="title">番外：Go接口的设计哲学</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Adam Ben</div><div class="author-info__description">你的孤独与月为伴，你的深情与星同归</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">58</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Adam8en"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Adam8en" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:adamben@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://blog.csdn.net/Adam_Ben?type=blog" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=2813879949&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">不知道说什么好,<br>放个表情包在这里好了,<br>⁽˙³˙⁾◟(๑•́ ₃ •̀๑)◞⁽˙³˙⁾</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-number">1.</span> <span class="toc-text"> 88. 合并两个有序数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-number">1.1.</span> <span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text"> 解题方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.3.</span> <span class="toc-text"> 复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code"><span class="toc-number">1.4.</span> <span class="toc-text"> Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">2.</span> <span class="toc-text"> 27. 移除元素</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-2"><span class="toc-number">2.1.</span> <span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%96%B9%E6%B3%95-2"><span class="toc-number">2.2.</span> <span class="toc-text"> 解题方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-2"><span class="toc-number">2.3.</span> <span class="toc-text"> 复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code-2"><span class="toc-number">2.4.</span> <span class="toc-text"> Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#26%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="toc-number">3.</span> <span class="toc-text"> 26.删除有序数组中的重复项</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-3"><span class="toc-number">3.1.</span> <span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%96%B9%E6%B3%95-3"><span class="toc-number">3.2.</span> <span class="toc-text"> 解题方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-3"><span class="toc-number">3.3.</span> <span class="toc-text"> 复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code-3"><span class="toc-number">3.4.</span> <span class="toc-text"> Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#80%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-ii"><span class="toc-number">4.</span> <span class="toc-text"> 80.删除有序数组中的重复项 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-4"><span class="toc-number">4.1.</span> <span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%96%B9%E6%B3%95-4"><span class="toc-number">4.2.</span> <span class="toc-text"> 解题方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-4"><span class="toc-number">4.3.</span> <span class="toc-text"> 复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code-4"><span class="toc-number">4.4.</span> <span class="toc-text"> Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0"><span class="toc-number">5.</span> <span class="toc-text"> 169. 多数元素</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-5"><span class="toc-number">5.1.</span> <span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%96%B9%E6%B3%95-5"><span class="toc-number">5.2.</span> <span class="toc-text"> 解题方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#boyer-moore%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95"><span class="toc-number">5.2.1.</span> <span class="toc-text"> Boyer-Moore投票算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-5"><span class="toc-number">5.3.</span> <span class="toc-text"> 复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code-5"><span class="toc-number">5.4.</span> <span class="toc-text"> Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#189%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="toc-number">6.</span> <span class="toc-text"> 189.轮转数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-6"><span class="toc-number">6.1.</span> <span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%96%B9%E6%B3%95-6"><span class="toc-number">6.2.</span> <span class="toc-text"> 解题方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-6"><span class="toc-number">6.3.</span> <span class="toc-text"> 复杂度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#121%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="toc-number">7.</span> <span class="toc-text"> 121.买卖股票的最佳时机</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-7"><span class="toc-number">7.1.</span> <span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%96%B9%E6%B3%95-7"><span class="toc-number">7.2.</span> <span class="toc-text"> 解题方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-7"><span class="toc-number">7.3.</span> <span class="toc-text"> 复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code-6"><span class="toc-number">7.4.</span> <span class="toc-text"> Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#122%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-ii"><span class="toc-number">8.</span> <span class="toc-text"> 122.买卖股票的最佳时机 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-8"><span class="toc-number">8.1.</span> <span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%96%B9%E6%B3%95-8"><span class="toc-number">8.2.</span> <span class="toc-text"> 解题方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-8"><span class="toc-number">8.3.</span> <span class="toc-text"> 复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code-7"><span class="toc-number">8.4.</span> <span class="toc-text"> Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#55%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="toc-number">9.</span> <span class="toc-text"> 55.跳跃游戏</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-9"><span class="toc-number">9.1.</span> <span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%96%B9%E6%B3%95-9"><span class="toc-number">9.2.</span> <span class="toc-text"> 解题方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-9"><span class="toc-number">9.3.</span> <span class="toc-text"> 复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code-8"><span class="toc-number">9.4.</span> <span class="toc-text"> Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#45%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-ii"><span class="toc-number">10.</span> <span class="toc-text"> 45.跳跃游戏 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-10"><span class="toc-number">10.1.</span> <span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%96%B9%E6%B3%95-10"><span class="toc-number">10.2.</span> <span class="toc-text"> 解题方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-10"><span class="toc-number">10.3.</span> <span class="toc-text"> 复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code-9"><span class="toc-number">10.4.</span> <span class="toc-text"> Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#274h-%E6%8C%87%E6%95%B0"><span class="toc-number">11.</span> <span class="toc-text"> 274.H 指数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-11"><span class="toc-number">11.1.</span> <span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%96%B9%E6%B3%95-11"><span class="toc-number">11.2.</span> <span class="toc-text"> 解题方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-11"><span class="toc-number">11.3.</span> <span class="toc-text"> 复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code-10"><span class="toc-number">11.4.</span> <span class="toc-text"> Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#380o1-%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5-%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0"><span class="toc-number">12.</span> <span class="toc-text"> 380.O(1) 时间插入、删除和获取随机元素</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-12"><span class="toc-number">12.1.</span> <span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%96%B9%E6%B3%95-12"><span class="toc-number">12.2.</span> <span class="toc-text"> 解题方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-12"><span class="toc-number">12.3.</span> <span class="toc-text"> 复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code-11"><span class="toc-number">12.4.</span> <span class="toc-text"> Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#238%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF"><span class="toc-number">13.</span> <span class="toc-text"> 238.除自身以外数组的乘积</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-13"><span class="toc-number">13.1.</span> <span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%96%B9%E6%B3%95-13"><span class="toc-number">13.2.</span> <span class="toc-text"> 解题方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-13"><span class="toc-number">13.3.</span> <span class="toc-text"> 复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code-12"><span class="toc-number">13.4.</span> <span class="toc-text"> Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#134%E5%8A%A0%E6%B2%B9%E7%AB%99"><span class="toc-number">14.</span> <span class="toc-text"> 134.加油站</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-14"><span class="toc-number">14.1.</span> <span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%96%B9%E6%B3%95-14"><span class="toc-number">14.2.</span> <span class="toc-text"> 解题方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-14"><span class="toc-number">14.3.</span> <span class="toc-text"> 复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code-13"><span class="toc-number">14.4.</span> <span class="toc-text"> Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#135%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C"><span class="toc-number">15.</span> <span class="toc-text"> 135.分发糖果</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-15"><span class="toc-number">15.1.</span> <span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%96%B9%E6%B3%95-15"><span class="toc-number">15.2.</span> <span class="toc-text"> 解题方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-15"><span class="toc-number">15.3.</span> <span class="toc-text"> 复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code-14"><span class="toc-number">15.4.</span> <span class="toc-text"> Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#42%E6%8E%A5%E9%9B%A8%E6%B0%B4"><span class="toc-number">16.</span> <span class="toc-text"> 42.接雨水</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-16"><span class="toc-number">16.1.</span> <span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%96%B9%E6%B3%95-16"><span class="toc-number">16.2.</span> <span class="toc-text"> 解题方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%B8%80"><span class="toc-number">16.2.1.</span> <span class="toc-text"> 解法一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%BA%8C"><span class="toc-number">16.2.2.</span> <span class="toc-text"> 解法二</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-16"><span class="toc-number">16.3.</span> <span class="toc-text"> 复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code-15"><span class="toc-number">16.4.</span> <span class="toc-text"> Code</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%B8%80-2"><span class="toc-number">16.4.1.</span> <span class="toc-text"> 解法一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%BA%8C-2"><span class="toc-number">16.4.2.</span> <span class="toc-text"> 解法二</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0"><span class="toc-number">17.</span> <span class="toc-text"> 13.罗马数字转整数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-17"><span class="toc-number">17.1.</span> <span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%96%B9%E6%B3%95-17"><span class="toc-number">17.2.</span> <span class="toc-text"> 解题方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-17"><span class="toc-number">17.3.</span> <span class="toc-text"> 复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code-16"><span class="toc-number">17.4.</span> <span class="toc-text"> Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97"><span class="toc-number">18.</span> <span class="toc-text"> 12.整数转罗马数字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-18"><span class="toc-number">18.1.</span> <span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%96%B9%E6%B3%95-18"><span class="toc-number">18.2.</span> <span class="toc-text"> 解题方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-18"><span class="toc-number">18.3.</span> <span class="toc-text"> 复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code-17"><span class="toc-number">18.4.</span> <span class="toc-text"> Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#58%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="toc-number">19.</span> <span class="toc-text"> 58.最后一个单词的长度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-19"><span class="toc-number">19.1.</span> <span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%96%B9%E6%B3%95-19"><span class="toc-number">19.2.</span> <span class="toc-text"> 解题方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-19"><span class="toc-number">19.3.</span> <span class="toc-text"> 复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code-18"><span class="toc-number">19.4.</span> <span class="toc-text"> Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80"><span class="toc-number">20.</span> <span class="toc-text"> 14.最长公共前缀</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-20"><span class="toc-number">20.1.</span> <span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%96%B9%E6%B3%95-20"><span class="toc-number">20.2.</span> <span class="toc-text"> 解题方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-20"><span class="toc-number">20.3.</span> <span class="toc-text"> 复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code-19"><span class="toc-number">20.4.</span> <span class="toc-text"> Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#151%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D"><span class="toc-number">21.</span> <span class="toc-text"> 151.反转字符串中的单词</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-21"><span class="toc-number">21.1.</span> <span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%96%B9%E6%B3%95-21"><span class="toc-number">21.2.</span> <span class="toc-text"> 解题方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-21"><span class="toc-number">21.3.</span> <span class="toc-text"> 复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code-20"><span class="toc-number">21.4.</span> <span class="toc-text"> Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2"><span class="toc-number">22.</span> <span class="toc-text"> 6.Z字形变换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-22"><span class="toc-number">22.1.</span> <span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%96%B9%E6%B3%95-22"><span class="toc-number">22.2.</span> <span class="toc-text"> 解题方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-22"><span class="toc-number">22.2.1.</span> <span class="toc-text"> 复杂度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code-21"><span class="toc-number">22.3.</span> <span class="toc-text"> Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#28%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87"><span class="toc-number">23.</span> <span class="toc-text"> 28.找出字符串中第一个匹配项的下标</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-23"><span class="toc-number">23.1.</span> <span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%96%B9%E6%B3%95-23"><span class="toc-number">23.2.</span> <span class="toc-text"> 解题方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-23"><span class="toc-number">23.3.</span> <span class="toc-text"> 复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code-22"><span class="toc-number">23.4.</span> <span class="toc-text"> Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#68%E6%96%87%E6%9C%AC%E5%B7%A6%E5%8F%B3%E5%AF%B9%E9%BD%90"><span class="toc-number">24.</span> <span class="toc-text"> 68.文本左右对齐</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-24"><span class="toc-number">24.1.</span> <span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%96%B9%E6%B3%95-24"><span class="toc-number">24.2.</span> <span class="toc-text"> 解题方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-24"><span class="toc-number">24.3.</span> <span class="toc-text"> 复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code-23"><span class="toc-number">24.4.</span> <span class="toc-text"> Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#125%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="toc-number">25.</span> <span class="toc-text"> 125.验证回文串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-25"><span class="toc-number">25.1.</span> <span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%96%B9%E6%B3%95-25"><span class="toc-number">25.2.</span> <span class="toc-text"> 解题方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-25"><span class="toc-number">25.3.</span> <span class="toc-text"> 复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code-24"><span class="toc-number">25.4.</span> <span class="toc-text"> Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#392%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">26.</span> <span class="toc-text"> 392.判断子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-26"><span class="toc-number">26.1.</span> <span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%96%B9%E6%B3%95-26"><span class="toc-number">26.2.</span> <span class="toc-text"> 解题方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-26"><span class="toc-number">26.3.</span> <span class="toc-text"> 复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code-25"><span class="toc-number">26.4.</span> <span class="toc-text"> Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#167%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-ii-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-number">27.</span> <span class="toc-text"> 167.两数之和 II - 输入有序数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-27"><span class="toc-number">27.1.</span> <span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%96%B9%E6%B3%95-27"><span class="toc-number">27.2.</span> <span class="toc-text"> 解题方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-27"><span class="toc-number">27.3.</span> <span class="toc-text"> 复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code-26"><span class="toc-number">27.4.</span> <span class="toc-text"> Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">28.</span> <span class="toc-text"> 11.盛最多水的容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-28"><span class="toc-number">28.1.</span> <span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%96%B9%E6%B3%95-28"><span class="toc-number">28.2.</span> <span class="toc-text"> 解题方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-28"><span class="toc-number">28.3.</span> <span class="toc-text"> 复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code-27"><span class="toc-number">28.4.</span> <span class="toc-text"> Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">29.</span> <span class="toc-text"> 15.三数之和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-29"><span class="toc-number">29.1.</span> <span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%96%B9%E6%B3%95-29"><span class="toc-number">29.2.</span> <span class="toc-text"> 解题方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-29"><span class="toc-number">29.3.</span> <span class="toc-text"> 复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code-28"><span class="toc-number">29.4.</span> <span class="toc-text"> Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#209%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">30.</span> <span class="toc-text"> 209.长度最小的子数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-30"><span class="toc-number">30.1.</span> <span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E8%BF%87%E7%A8%8B"><span class="toc-number">30.2.</span> <span class="toc-text"> 解题过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-30"><span class="toc-number">30.3.</span> <span class="toc-text"> 复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code-29"><span class="toc-number">30.4.</span> <span class="toc-text"> Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="toc-number">31.</span> <span class="toc-text"> 3.无重复字符的最长子串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-31"><span class="toc-number">31.1.</span> <span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E8%BF%87%E7%A8%8B-2"><span class="toc-number">31.2.</span> <span class="toc-text"> 解题过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-31"><span class="toc-number">31.3.</span> <span class="toc-text"> 复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code-30"><span class="toc-number">31.4.</span> <span class="toc-text"> Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#30%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2"><span class="toc-number">32.</span> <span class="toc-text"> 30.串联所有单词的子串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-32"><span class="toc-number">32.1.</span> <span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E8%BF%87%E7%A8%8B-3"><span class="toc-number">32.2.</span> <span class="toc-text"> 解题过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-32"><span class="toc-number">32.3.</span> <span class="toc-text"> 复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code-31"><span class="toc-number">32.4.</span> <span class="toc-text"> Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#76%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2"><span class="toc-number">33.</span> <span class="toc-text"> 76.最小覆盖子串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-33"><span class="toc-number">33.1.</span> <span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E8%BF%87%E7%A8%8B-4"><span class="toc-number">33.2.</span> <span class="toc-text"> 解题过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-33"><span class="toc-number">33.3.</span> <span class="toc-text"> 复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code-32"><span class="toc-number">33.4.</span> <span class="toc-text"> Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#36%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC"><span class="toc-number">34.</span> <span class="toc-text"> 36.有效的数独</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-34"><span class="toc-number">34.1.</span> <span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E8%BF%87%E7%A8%8B-5"><span class="toc-number">34.2.</span> <span class="toc-text"> 解题过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-34"><span class="toc-number">34.3.</span> <span class="toc-text"> 复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code-33"><span class="toc-number">34.4.</span> <span class="toc-text"> Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#54%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5"><span class="toc-number">35.</span> <span class="toc-text"> 54.螺旋矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-35"><span class="toc-number">35.1.</span> <span class="toc-text"> 思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E8%BF%87%E7%A8%8B-6"><span class="toc-number">35.2.</span> <span class="toc-text"> 解题过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-35"><span class="toc-number">35.3.</span> <span class="toc-text"> 复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code-34"><span class="toc-number">35.4.</span> <span class="toc-text"> Code</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/30b9345756ad/" title="OS Lab"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/64495434_p0.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OS Lab"/></a><div class="content"><a class="title" href="/posts/30b9345756ad/" title="OS Lab">OS Lab</a><time datetime="2024-10-10T11:11:27.000Z" title="发表于 2024-10-10 19:11:27">2024-10-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/7a99acb03ff0/" title="番外：Go接口的设计哲学"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/d367a38091cb770dfa360d3dbf289740.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="番外：Go接口的设计哲学"/></a><div class="content"><a class="title" href="/posts/7a99acb03ff0/" title="番外：Go接口的设计哲学">番外：Go接口的设计哲学</a><time datetime="2024-10-09T05:57:54.000Z" title="发表于 2024-10-09 13:57:54">2024-10-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/186ad852eeaf/" title="9月总结·2024"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/26424396_p0.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="9月总结·2024"/></a><div class="content"><a class="title" href="/posts/186ad852eeaf/" title="9月总结·2024">9月总结·2024</a><time datetime="2024-09-30T11:25:12.000Z" title="发表于 2024-09-30 19:25:12">2024-09-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/1c2342ee510b/" title="计算机组成指北（七）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/C10AD1752A521C3C297E7D81400952F1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机组成指北（七）"/></a><div class="content"><a class="title" href="/posts/1c2342ee510b/" title="计算机组成指北（七）">计算机组成指北（七）</a><time datetime="2024-09-27T03:43:26.000Z" title="发表于 2024-09-27 11:43:26">2024-09-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4ddedbf342f8/" title="计算机组成指北（六）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/612FFB2DEDE35B9C77545DB9ADF1C8BF.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机组成指北（六）"/></a><div class="content"><a class="title" href="/posts/4ddedbf342f8/" title="计算机组成指北（六）">计算机组成指北（六）</a><time datetime="2024-09-27T03:43:17.000Z" title="发表于 2024-09-27 11:43:17">2024-09-27</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://adam8en-blog-image.oss-cn-guangzhou.aliyuncs.com/%7B930EB68A-6F85-4666-BA42-9333A5074315%7D.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Adam Ben</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addModeChange('mermaid', runMermaid)

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '07g7RVgbp0tb6j6gBjcZCTKv-gzGzoHsz',
      appKey: '4w4tpzByVtxnDriO8BFDKLBt',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><canvas id="universe"></canvas><script src="/js/universe.js"></script><script src="/js/sun_moon.js" async></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="富强,民主,文明,和谐,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":200,"height":400},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>